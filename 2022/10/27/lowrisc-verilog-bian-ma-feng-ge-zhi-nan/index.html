<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="lowRISC Verilog 编码风格指南, wutaoのblog">
    <meta name="description" content="个人博客">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>lowRISC Verilog 编码风格指南 | wutaoのblog</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="wutaoのblog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>



   <style>
    body{
       background-image: url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">wutaoのblog</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">wutaoのblog</div>
        <div class="logo-desc">
            
            个人博客
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">lowRISC Verilog 编码风格指南</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-10-27
                </div>
                

                

                

                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="lowRISC-Verilog-编码风格指南"><a href="#lowRISC-Verilog-编码风格指南" class="headerlink" title="lowRISC Verilog 编码风格指南"></a>lowRISC Verilog 编码风格指南</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>Verilog 是低RISC 可移植IP 的主要逻辑设计语言。</p>
<p>Verilog 和 SystemVerilog（在本文档中通常简称为“Verilog”）可以以截然不同的风格编写，这可能导致代码冲突和代码审查延迟。本样式指南旨在提高 Verilog 跨组的可读性。引用 <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html">Google C++ 风格指南</a>：“创建通用的、必需的习语和模式使代码更容易理解。”</p>
<p>本指南定义了 Verilog 的可移植样式。目标是：</p>
<ul>
<li>促进硬件开发项目的一致性</li>
<li>推广最佳实践</li>
<li>增加代码共享和重用</li>
</ul>
<p>本样式指南定义了 Verilog-2001 和 SystemVerilog 兼容代码的样式。此外，本样式指南定义了可综合代码和测试台代码的样式。</p>
<p>有关此样式指南的简明表格表示，请参见<a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#appendix---condensed-style-guide">附录。</a></p>
<p><strong>目录</strong></p>
<ul>
<li>lowRISC Verilog 编码风格指南<ul>
<li>基本<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#summary">概括</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#terminology-conventions">术语约定</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#default-to-c-like-formatting">默认为类 C 格式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#style-guide-exceptions">样式指南例外</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#which-verilog-to-use">使用哪个 Verilog</a></li>
</ul>
</li>
<li>Verilog/SystemVerilog 约定<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#summary-1">概括</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#file-extensions">文件扩展名</a></li>
<li>一般文件外观<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#characters">人物</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#posix-file-endings">POSIX 文件结尾</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#line-length">线长</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#no-tabs">没有标签</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#no-trailing-spaces">没有尾随空格</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#begin--end">开始/结束</a></li>
<li>缩进<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#indented-sections">缩进部分</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#line-wrapping">换行</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#preprocessor-directives">预处理器指令</a></li>
</ul>
</li>
<li>间距<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#comma-delimited-lists">逗号分隔的列表</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#tabular-alignment">表格对齐</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#expressions">表达式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#array-dimensions-in-declarations">声明中的数组维度</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#parameterized-types">参数化类型</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#labels">标签</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#case-items">案例项目</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#function-and-task-calls">函数和任务调用</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#macro-calls">宏调用</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#line-continuation">续行</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#space-around-keywords">关键字周围的空间</a></li>
</ul>
</li>
<li>括号<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#ternary-expressions">三元表达式</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#comments">注释</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#declarations">声明</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#basic-template">基本模板</a></li>
</ul>
</li>
<li>我们<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#summary-2">概括</a></li>
<li>常数<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#parameterized-objects-modules-etc">参数化对象（模块等）</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#macro-definitions">宏定义</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#suffixes">后缀</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#enumerations">枚举</a></li>
<li>信号命名<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#use-descriptive-names">使用描述性名称</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#prefixes">前缀</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#hierarchical-consistency">层次一致性</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#clocks">时钟</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#resets">重置</a></li>
</ul>
</li>
<li>语言特点<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#preferred-systemverilog-constructs">首选 SystemVerilog 构造</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#package-dependencies">包依赖</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#module-declaration">模块声明</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#module-instantiation">模块实例化</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants-1">常数</a></li>
<li>信号宽度<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#always-be-explicit-about-the-widths-of-number-literals">始终明确数字文字的宽度。</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#port-connections-on-module-instances-must-always-match-widths-correctly">模块实例上的端口连接必须始终正确匹配宽度。</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#do-not-use-multi-bit-signals-in-a-boolean-context">不要在布尔上下文中使用多位信号。</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#bit-slicing">位切片</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#handling-width-overflow">处理宽度溢出</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#blocking-and-non-blocking-assignments">阻塞和非阻塞赋值</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#delay-modeling">延迟建模</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#sequential-logic-latches">顺序逻辑（锁存器）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#sequential-logic-registers">顺序逻辑（寄存器）</a></li>
<li>不在乎（<code>X</code>‘s）<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#catching-errors-where-invalid-values-are-consumed">捕获使用无效值的错误</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#specific-guidance-on-case-statements-and-ternaries">案例陈述和三元组的具体指导</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#dynamic-array-indexing">动态数组索引</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#combinational-logic">组合逻辑</a></li>
<li>案例陈述<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#wildcards-in-case-items">案例项目中的通配符</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#generate-constructs">生成构造</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#signed-arithmetic">有符号算术</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#number-formatting">数字格式</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#functions-and-tasks">功能和任务</a></li>
<li>有问题的语言特征和结构<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#floating-begin-end-blocks">浮动起始块</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#hierarchical-references">分层引用</a></li>
</ul>
</li>
</ul>
</li>
<li>设计惯例<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#summary-3">概括</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#declare-all-signals">声明所有信号</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#use-logic-for-synthesis">用于<code>logic</code>合成</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#logical-vs-bitwise">逻辑与按位</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#packed-ordering">打包订购</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#unpacked-ordering">无包装订购</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#finite-state-machines">有限状态机</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#active-low-signals">低电平有效信号</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#differential-pairs">差分对</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#delays">延误</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#wildcard-import-of-packages">包的通配符导入</a></li>
<li>断言宏<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#a-note-on-security-critical-applications">关于安全关键应用程序的说明</a></li>
</ul>
</li>
</ul>
</li>
<li>附录 - 精简风格指南<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#basic-style-elements">基本样式元素</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#construct-naming">构造命名</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#suffixes-for-signals-and-types">信号和类型的后缀</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#language-features-1">语言特点</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="术语约定"><a href="#术语约定" class="headerlink" title="术语约定"></a>术语约定</h3><p>除非另有说明，否则以下术语约定适用于本样式指南：</p>
<ul>
<li><em><strong>“必须</strong></em>”一词表示强制性要求。同样，<em><strong>不</strong></em>表示禁止。命令式和声明式语句对应于<em><strong>must</strong></em>。</li>
<li><em><strong>推荐</strong></em>这个词表示某种行动方案是首选或最合适的。类似地，<em><strong>不推荐</strong></em>表示一个行动过程不合适，但不被禁止。使用其他选项可能有理由，但必须充分理解这样做的含义和原因。</li>
<li><em><strong>“可能</strong></em>”一词表示允许和可选的操作过程。</li>
<li><em><strong>“可以</strong></em>”这个词表示在物质、物理或因果限制的情况下可能采取的行动。</li>
</ul>
<h3 id="默认为类-C-格式"><a href="#默认为类-C-格式" class="headerlink" title="默认为类 C 格式"></a>默认为类 C 格式</h3><p><em><strong>在适当的情况下，格式代码与 <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html一致</a></strong></em></p>
<p>Verilog 是一种类 C 语言，在适当的情况下，我们默认与 <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html">Google 的 C++ 样式指南</a>保持一致。</p>
<p>特别是，我们继承了这些特定的格式指南：</p>
<ul>
<li>一般来说，<a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#naming">名称</a>应该是描述性的，避免缩写。</li>
<li>禁止使用非 ASCII 字符。</li>
<li>缩进使用空格，没有制表符。缩进是两个空格用于嵌套，四个空格用于续行。</li>
<li><code>if</code>在 <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#Conditionals">条件表达式</a>中的括号和括号之间放置一个空格。</li>
<li>在运算符周围使用水平空格，并避免在行尾出现尾随空格。</li>
<li>保持一致和良好的 <a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#Punctuation,_Spelling_and_Grammar">标点、拼写和语法</a> （在评论中）。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#comments">对注释</a>使用标准格式，包括<a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#TODO_Comments">TODO</a>和<a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#Deprecation_Comments">deprecation</a>的类 C 格式。</li>
</ul>
<h3 id="样式指南例外"><a href="#样式指南例外" class="headerlink" title="样式指南例外"></a>样式指南例外</h3><p><em><strong>用评论证明所有例外。</strong></em></p>
<p>没有风格指南是完美的。有时，实现工作设计或解决工具问题的最佳途径是简单地切断 Gordian Knot 并创建与本样式指南不一致的代码。必要时偏离风格指南总是可以的，只要简短的评论清楚地证明了这种必要性，以及适当的 lint waiver pragma。</p>
<h3 id="使用哪个-Verilog"><a href="#使用哪个-Verilog" class="headerlink" title="使用哪个 Verilog"></a>使用哪个 Verilog</h3><p><em><strong>首选 SystemVerilog-2017。</strong></em></p>
<p>所有 RTL 和测试都应在 SystemVerilog 中开发，遵循 <a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/8299595">IEEE 1800-2017 (SystemVerilog-2017) 标准，</a><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#problematic-language-features-and-constructs">禁止的功能</a>除外。</p>
<p><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/browse/standards/get-program/page/series?id=80">标准文档可通过IEEE GET</a>免费获得（需要注册）。</p>
<h2 id="Verilog-SystemVerilog-约定"><a href="#Verilog-SystemVerilog-约定" class="headerlink" title="Verilog/SystemVerilog 约定"></a>Verilog/SystemVerilog 约定</h2><h3 id="概括-1"><a href="#概括-1" class="headerlink" title="概括"></a>概括</h3><p>本节主要讨论风格的美学方面：行长、缩进、间距等。</p>
<h3 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h3><p><em><strong>使用<code>.sv</code>SystemVerilog 文件的扩展名（或<code>.svh</code>通过预处理器包含的文件）。</strong></em></p>
<p>文件扩展名具有以下含义：</p>
<ul>
<li><code>.sv</code>表示定义模块或包的 SystemVerilog 文件。</li>
<li><code>.svh</code>表示一个 SystemVerilog 头文件，旨在使用预处理器``include`指令包含在另一个文件中。</li>
<li><code>.v</code>表示定义模块或包的 Verilog-2001 文件。</li>
<li><code>.vh</code>表示 Verilog-2001 头文件。</li>
</ul>
<p>只有<code>.sv</code>和<code>.v</code>文件旨在作为编译单元。<code>.svh</code>并且<code>.vh</code> 文件只能被``include`编辑到其他文件中。</p>
<p>除网表文件外，每个 .sv 或 .v 文件应仅包含一个模块，并且名称应相关联。例如，文件<code>foo.sv</code>应该只包含模块<code>foo</code>。</p>
<h3 id="一般文件外观"><a href="#一般文件外观" class="headerlink" title="一般文件外观"></a>一般文件外观</h3><h4 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h4><p><em><strong>仅使用带有 UNIX 风格行尾 ( <code>"\n"</code>) 的 ASCII 字符。</strong></em></p>
<h4 id="POSIX-文件结尾"><a href="#POSIX-文件结尾" class="headerlink" title="POSIX 文件结尾"></a>POSIX 文件结尾</h4><p><em><strong>非空文件上的所有行都必须以换行符 ( <code>"\n"</code>) 结尾。</strong></em></p>
<h4 id="线长"><a href="#线长" class="headerlink" title="线长"></a>线长</h4><p><em><strong>以每行 100 个字符包装代码。</strong></em></p>
<p>符合样式的 Verilog 代码的最大行长度为每行 100 个字符。</p>
<p>例外：</p>
<ul>
<li>任何不可能换行的地方（例如，包含路径可能超过 100 个字符）。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#line-wrapping">换行</a>包含有关如何换行长行的附加指南。</p>
<h4 id="没有标签"><a href="#没有标签" class="headerlink" title="没有标签"></a>没有标签</h4><p><em><strong>不要在任何地方使用标签。</strong></em></p>
<p>使用空格缩进或对齐文本。有关缩进和换行的规则，请参阅<a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#indentation">缩进。</a></p>
<p>要将任何文件上的制表符转换为空格，您可以使用 <a target="_blank" rel="noopener" href="http://linux.die.net/man/1/expand">UNIX<code>expand</code></a>实用程序。</p>
<h4 id="没有尾随空格"><a href="#没有尾随空格" class="headerlink" title="没有尾随空格"></a>没有尾随空格</h4><p><em><strong>删除行尾的尾随空格。</strong></em></p>
<h3 id="开始-结束"><a href="#开始-结束" class="headerlink" title="开始/结束"></a>开始/结束</h3><p><em><strong>使用<code>begin</code>and<code>end</code>除非整个语句适合一行。</strong></em></p>
<p>如果语句在块边界处换行，则必须使用<code>begin</code>and<code>end.</code>仅当整个以分号结尾的语句适合单行时才可以<code>begin</code>省略 <code>end</code>。</p>
<p>👍</p>
<pre><code>// Wrapped procedural block requires begin and end.
always_ff @(posedge clk) begin
  q &lt;= d;
end
</code></pre>
<p>👍</p>
<pre><code>// The exception case, where begin and end may be omitted as the entire
// structure fits on a single line.
always_ff @(posedge clk) q &lt;= d;
</code></pre>
<p>👎</p>
<pre><code>// Incorrect because a wrapped statement must have begin and end.
always_ff @(posedge clk)
  q &lt;= d;
</code></pre>
<p><code>begin</code>必须与前面的关键字在同一行，并结束该行。 <code>end</code>必须开始一个新行。<code>end else begin</code>必须在一条线上。唯一的例外是如果<code>end</code>有标签，则后续<code>else</code>应该在新行上。</p>
<p>👍</p>
<pre><code>// "end else begin" are on the same line.
if (condition) begin
  foo = bar;
end else begin
  foo = bum;
end
</code></pre>
<p>👍</p>
<pre><code>// begin/end are omitted because each semicolon-terminated statement fits on
// a single line.
if (condition) foo = bar;
else foo = bum;
</code></pre>
<p>👎</p>
<pre><code>// Incorrect because "else" must be on the same line as "end".
if (condition) begin
  foo = bar;
end
else begin
  foo = bum;
end
</code></pre>
<p>👍</p>
<pre><code>// An exception is made for labeled blocks.
if (condition) begin : a
  foo = bar;
end : a
else begin : b
  foo = bum;
end : b
</code></pre>
<p>上述风格也适用于案例陈述中的个别案例项目。 如果整个 case 项（case 表达式和相关的语句）适合一行，则可以省略<code>begin</code>。<code>end</code>否则，<code>begin</code> 在与 case 表达式相同的行上使用关键字。</p>
<p>👍</p>
<pre><code>// Consistent use of begin and end for each case item is good.
unique case (state_q)
  StIdle: begin
    state_d = StA;
  end
  StA: begin
    state_d = StB;
  end
  StB: begin
    state_d = StIdle;
    foo = bar;
  end
  default: begin
    state_d = StIdle;
  end
endcase
</code></pre>
<p>👍</p>
<pre><code>// Case items that fit on a single line may omit begin and end.
unique case (state_q)
  StIdle: state_d = StA;
  StA: state_d = StB;
  StB: begin
    state_d = StIdle;
    foo = bar;
  end
  default: state_d = StIdle;
endcase
</code></pre>
<p>👎</p>
<pre><code>unique case (state_q)
  StIdle:           // These lines are incorrect because we should not wrap
    state_d = StA;  // case items at a block boundary without using begin
  StA:              // and end.  Case items should fit on a single line, or
    state_d = StB;  // else the procedural block must have begin and end.
  StB: begin
    foo = bar;
    state_d = StIdle;
  end
  default: begin
    state_d = StIdle;
  end
endcase
</code></pre>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><em><strong>缩进是每层两个空格。</strong></em></p>
<p>使用空格进行缩进。不要使用标签。您应该将编辑器设置为在您按 Tab 键时发出空格。</p>
<h4 id="缩进部分"><a href="#缩进部分" class="headerlink" title="缩进部分"></a>缩进部分</h4><p>始终为所有配对关键字的封闭部分添加额外的缩进级别。SystemVerilog 关键字对示例：<code>begin / end</code>, <code>module / endmodule</code>, <code>package / endpackage</code>, <code>class / endclass</code>, <code>function / endfunction</code>.</p>
<h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>包装长表达式时，将表达式的连续部分缩进四个空格，如下所示：</p>
<p>👍</p>
<pre><code>assign zulu = enabled &amp;&amp; (
    alpha &lt; bravo &amp;&amp;
    charlie &lt; delta
);

assign addr = addr_gen_function_with_many_params(
    thing, other_thing, long_parameter_name, x, y,
    extra_param1, extra_param2
);

assign structure = '{
    src: src,
    dest: dest,
    default: '0
};
</code></pre>
<p>或者，如果它提高了可读性，则将表达式的后续部分与分组左括号或大括号对齐，如下所示：</p>
<p>👍</p>
<pre><code>assign zulu = enabled &amp;&amp; (alpha &lt; bravo &amp;&amp;
                          charlie &lt; delta);

assign addr = addr_gen_function(thing, other_thing,
                                long_parameter_name,
                                x, y);

assign structure = '{src: src,
                     dest: dest,
                     default: '0};
</code></pre>
<p>包装表达式中的运算符可以放在每行的末尾或开头，但这必须在文件中一致地完成。</p>
<p>多行表达式的一行结束的开放语法字符（例如<code>{</code>或）应在各自的行上以关闭字符 ( , ) 终止。例子：<code>(``}``)</code></p>
<p>👍</p>
<pre><code>assign bus_concatenation = {
    bus_valid,
    bus_parity[7:0],
    bus_valid[63:0]
};

inst_type inst_name1 (
  .clk_i       (clk),
  .data_valid_i(data_valid),
  .data_value_i(data_value),
  .data_ready_o(data_ready)
);
</code></pre>
<h4 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h4><p><em><strong>保持分支预处理器指令左对齐且不缩进。</strong></em></p>
<p>保持分支预处理器指令（<code> </code>ifdef<code>, ``ifndef</code>, <code>else`, </code>elsif<code>, ``endif</code>）左对齐，即使它们是嵌套的。缩进文本的条件分支，就好像没有预处理器指令一样。非分支预处理器指令必须遵循与常规代码相同的缩进规则。</p>
<p>👍</p>
<pre><code>package foo;
`ifdef FOO              // good: branching directive left-aligned
  `include "foo.sv";    // normal indentation for non-branching directives
  parameter bit A = 1;  // normal indentation for the regular code
`ifdef BAR              // good: branching directive left-aligned
  parameter bit A = 2;
`else
  parameter bit A = 3;
`endif
`endif
endpackage : foo
</code></pre>
<p>未缩进的分支预处理器指令会破坏阅读流程以强调存在条件文本。保留条件分支文本不缩进将导致预处理后的文本看起来正确缩进。</p>
<h3 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h3><h4 id="逗号分隔的列表"><a href="#逗号分隔的列表" class="headerlink" title="逗号分隔的列表"></a>逗号分隔的列表</h4><p><em><strong>对于一行中的多个项目，一个空格必须分隔逗号和下一个字符。</strong></em></p>
<p>为了便于阅读，允许使用额外的空格。</p>
<p>👍</p>
<pre><code>bus = {addr, parity, data};
a = myfunc(lorem, ipsum, dolor, sit, amet, consectetur, adipiscing, elit,
           rhoncus);
mymodule mymodule(.a(a), .b(b));
</code></pre>
<p>👎</p>
<pre><code>{parity,data} = bus;
a = myfunc(a,b,c);
mymodule mymodule(.a(a),.b(b));
</code></pre>
<h4 id="表格对齐"><a href="#表格对齐" class="headerlink" title="表格对齐"></a>表格对齐</h4><p>表格对齐方式将两条或多条相似的线组合在一起，使相同的部分直接位于彼此之上。这种对齐方式可以很容易地看出哪些字符是相同的，哪些字符是不同的。</p>
<p><em><strong>通常鼓励使用表格对齐。</strong></em></p>
<p><em><strong>如本指南的相应小节所述，某些结构需要使用表格对齐。</strong></em></p>
<p>需要表格对齐的结构：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#module-instantiation">模块实例化中的端口表达式</a></li>
</ul>
<p>每个由空行分隔的代码块都被视为单独的“表格”。</p>
<p>使用空格，而不是制表符。</p>
<p>例如：</p>
<p>👍</p>
<pre><code>logic [7:0]  my_interface_data;
logic [15:0] my_interface_address;
logic        my_interface_enable;

logic       another_signal;
logic [7:0] something_else;
</code></pre>
<p>👍</p>
<pre><code>mod u_mod (
  .clk_i,
  .rst_ni,
  .sig_i          (my_signal_in),
  .sig2_i         (my_signal_out),
  // comment with no blank line maintains the block
  .in_same_block_i(my_signal_in),
  .sig3_i         (something),

  .in_another_block_i(my_signal_in),
  .sig4_i            (something)
);
</code></pre>
<h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p><em><strong>在所有二元运算符的两边都包含空格。</strong></em></p>
<p>在二元运算符周围使用空格。添加足够的空格以提高可读性。</p>
<p>例如：</p>
<p>👍</p>
<pre><code>assign a = ((addr &amp; mask) == My_addr) ? b[1] : ~b[0];  // good
</code></pre>
<p>好于</p>
<p>👎</p>
<pre><code>assign a=((addr&amp;mask)==My_addr)?b[1]:~b[0];  // bad
</code></pre>
<p><strong>例外：</strong>声明位向量时，可以使用紧凑表示法。例如：</p>
<p>👍</p>
<pre><code>wire [WIDTH-1:0] foo;   // this is acceptable
wire [WIDTH - 1 : 0] foo;  // fine also, but not necessary
</code></pre>
<p>将替换表达式拆分为多行时，请使用与等效的 if-then-else 行类似的格式。例如：</p>
<p>👍</p>
<pre><code>assign a = ((addr &amp; mask) == `MY_ADDRESS) ?
           matches_value :
           doesnt_match_value;
</code></pre>
<h4 id="声明中的数组维度"><a href="#声明中的数组维度" class="headerlink" title="声明中的数组维度"></a>声明中的数组维度</h4><p>在压缩尺寸周围添加一个空格。</p>
<p>不要添加空格：</p>
<ul>
<li>在标识符和未包装尺寸之间。</li>
<li>多个维度之间。</li>
</ul>
<p>适用于打包和解包数组以及动态数组、关联数组和队列。</p>
<p>👍</p>
<pre><code>logic [7:0][3:0] data[128][2];
typedef logic [31:0] word_t;
bit bit_array[512];
data_t some_array[];
data_t some_map[addr_t];
data_t some_q[$];
</code></pre>
<p>👎</p>
<pre><code>// There must not be a space between dimensions.
logic [7:0] [3:0] data[128] [2];
// There must be a space around packed dimensions.
typedef logic[31:0]word_t;
// There must not be a space between identifier and unpacked dimension.
bit bit_array [512];
// Dynamic, associative, and queue "dimensions" are treated the same as unpacked
// dimensions.  There must not be a space.
data_t some_array [];
data_t some_map [addr_t];
data_t some_q [$];
</code></pre>
<h4 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h4><p><em><strong>在类型参数之前添加一个空格，除非类型是限定名称的一部分。</strong></em></p>
<p>限定名称包含至少一个<code>::</code>连接其段的范围运算符。限定名称中的空格会破坏对一个符号的引用的连续性，因此不得添加。参数列表必须遵循 <a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#comma-delimited-lists">逗号后空格</a>规则。</p>
<p>👍</p>
<pre><code>my_fifo #(.WIDTH(4), .DEPTH(2)) my_fifo_nibble ...

class foo extends bar #(32, 8);  // unqualified base class
  ...
endclass

foo_h = my_class#(.X(1), .Y(0))::type_id::create("foo_h");  // static method call

my_pkg::x_class#(8, 1) bar;  // package-qualified name
</code></pre>
<p>👎</p>
<pre><code>my_fifo#(.WIDTH(4), .DEPTH(2)) my_fifo_2by4 ...

class foo extends bar#(32, 8);  // unqualified base class
  ...
endclass

foo_h = my_class #(.X(1), .Y(0))::type_id::create("foo_h");  // static method call

my_pkg::x_class #(8, 1) bar;  // package-qualified name
</code></pre>
<h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p><em><strong>标记代码块时，冒号前后各加一个空格。</strong></em></p>
<p>例如：</p>
<p>👍</p>
<pre><code>begin : foo
end : foo
</code></pre>
<p>👎</p>
<pre><code>end:bar            // There must be a space before and after the colon.
endmodule: foobar  // There must be a space before the colon.
</code></pre>
<h4 id="案例项目"><a href="#案例项目" class="headerlink" title="案例项目"></a>案例项目</h4><p>案例项目的冒号之前不能有空格；案例项目的冒号后必须至少有一个空格。</p>
<p>案例项目<code>default</code>必须包含冒号。</p>
<p>例如：</p>
<p>👍</p>
<pre><code>unique case (my_state)
  StInit:   $display("Shall we begin");
  StError:  $display("Oh boy this is Bad");
  default: begin
    my_state = StInit;
    interrupt = 1;
  end
endcase
</code></pre>
<p>👎</p>
<pre><code>unique case (1'b1)
  (my_state == StError)  : interrupt = 1; // Excess whitespace before colon
  default:begin end                       // Missing space after colon
endcase
</code></pre>
<h4 id="函数和任务调用"><a href="#函数和任务调用" class="headerlink" title="函数和任务调用"></a>函数和任务调用</h4><p><em><strong>函数和任务调用在函数名称或任务名称与左括号之间不得有任何空格。</strong></em></p>
<p>例如：</p>
<p>👍</p>
<pre><code>process_packet(pkt);
</code></pre>
<p>👎</p>
<pre><code>process_packet (pkt);  // There must not be a space before "("
</code></pre>
<h4 id="宏调用"><a href="#宏调用" class="headerlink" title="宏调用"></a>宏调用</h4><p><em><strong>宏调用在宏名称和左括号之间不能有任何空格。</strong></em></p>
<p>例如：</p>
<p>👍</p>
<pre><code>`uvm_error(ID, "you fail")
`ASSERT(name, a &amp; b, clk, rst)
</code></pre>
<p>👎</p>
<pre><code>`uvm_error (ID, "you fail")  // There must not be a space before "("
`ASSERT (name, a &amp; b, clk, rst)
</code></pre>
<h4 id="续行"><a href="#续行" class="headerlink" title="续行"></a>续行</h4><p><em><strong>必须右对齐续行。</strong></em></p>
<p>对齐续行符（’ <code>\ </code>‘ 字符）有助于在视觉上标记多行宏的结尾。对齐位置只需要超出多行宏的最右边至少一个空格，当空格不分割标记时，但不应超过最大行长度。</p>
<pre><code>`define REALLY_LONG_MACRO(arg1, arg2, arg3) \
    do_something(arg1);                     \
    do_something_else(arg2);                \
    final_action(arg3);
</code></pre>
<h4 id="关键字周围的空间"><a href="#关键字周围的空间" class="headerlink" title="关键字周围的空间"></a>关键字周围的空间</h4><p><em><strong>在 SystemVerilog 关键字前后包含空格。</strong></em></p>
<p>不要包含空格：</p>
<ul>
<li>在紧跟在组开头之后的关键字之前，例如左括号。</li>
<li>在行首的关键字之前。</li>
<li>在行尾的关键字之后。</li>
</ul>
<p>例如：</p>
<pre><code>// Normal indentation before if.  Include a space after if.
if (foo) begin
end
// Include a space after always, but not before posedge.
always_ff @(posedge clk) begin
end
</code></pre>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p><em><strong>使用括号使操作明确。</strong></em></p>
<p>在任何情况下，如果一个理性的人需要思考或参考运算符优先级图表，请使用括号代替以使操作顺序明确。</p>
<h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><p><em><strong>嵌套在另一个三元表达式的真实条件中的三元表达式必须用括号括起来。</strong></em></p>
<p>例如：</p>
<p>👍</p>
<pre><code>assign foo = condition_a ? (condition_a_x ? x : y) : b;
</code></pre>
<p>虽然以下嵌套三元组对编译器只有一种含义，但其含义可能不清楚并且对人类来说很容易出错：</p>
<p>👎</p>
<pre><code>assign foo = condition_a ? condition_a_x ? x : y : b;
</code></pre>
<p><em><strong>如果代码格式传达相同的信息，例如在描述优先级复用器时，可以省略括号。</strong></em></p>
<p>👍</p>
<pre><code>assign foo = condition_a ? a :
             condition_b ? b : not_a_nor_b;
</code></pre>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><em><strong><code>// foo</code>首选C++ 样式注释 ( )。<code>/\* bar \*/</code>也可以使用C 风格的注释 ( )。</strong></em></p>
<p>单独一行的注释描述了后面的代码。对代码行的注释描述了该行代码。</p>
<p>例如：</p>
<pre><code>// This comment describes the following module.
module foo;
  ...
endmodule : foo

localparam bit ValBaz = 1;  // This comment describes the item to the left.
</code></pre>
<p>有时使用标题样式的注释来构造代码以分隔模块内的不同功能部分（如 FSM、主数据路径或寄存器）可能很有用。在这种情况下，首选样式是单行部分名称，并带有<code>//</code>C++ 样式注释，如下所示：</p>
<pre><code>module foo;

  ////////////////
  // Controller //
  ////////////////
  ...

  ///////////////////////
  // Main ALU Datapath //
  ///////////////////////
  ...

endmodule : foo
</code></pre>
<p>如果设计者想使用注释来标记特定部分的开始/结束以获得更好的可读性（例如，在嵌套的 for 循环块中），首选的方法是使用没有额外轮廓符的单行注释，如下面的例子。</p>
<p>👍</p>
<pre><code>// begin: iterate over foobar
for (...) begin
...
end
// end: iterate over foobar
</code></pre>
<p>👍</p>
<pre><code>for (...) begin // iterate over foobar
...
end // iterate over foobar
</code></pre>
<p>👎</p>
<pre><code>//-------------------------- iterate over foobar -------------------------------
for (...) begin
...
end
//-------------------------- iterate over foobar -------------------------------
</code></pre>
<p>👎</p>
<pre><code>///////////////////////////////
// begin iterate over foobar //
///////////////////////////////
for (...) begin
...
end
///////////////////////////////
// end iterate over foobar   //
///////////////////////////////
</code></pre>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><em><strong>信号必须在使用前声明。这意味着不得使用隐式网络声明。</strong></em></p>
<p>在模块中，<strong>建议</strong>在接近首次使用时声明信号、类型、枚举和本地参数。这使读者更容易找到声明并查看信号类型。</p>
<h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><p><em><strong>下面给出了演示许多项目的模板。</strong></em></p>
<p>模板：</p>
<pre><code>// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// One line description of the module

module my_module #(
  parameter Width = 80,
  parameter Height = 24
) (
  input              clk_i,
  input              rst_ni,
  input              req_valid_i,
  input  [Width-1:0] req_data_i,
  output             req_ready_o,
  ...
);

  logic [Width-1:0] req_data_masked;

  submodule u_submodule (
    .clk_i,
    .rst_ni,
    .req_valid_i,
    .req_data_i (req_data_masked),
    .req_ready_o(req_ready),
    ...
  );

  always_comb begin
    req_data_masked = req_data_i;
    case (fsm_state_q)
      ST_IDLE: begin
        req_data_masked = req_data_i &amp; MASK_IDLE;
        ...
  end

  ...

endmodule
</code></pre>
<h2 id="我们"><a href="#我们" class="headerlink" title="我们"></a>我们</h2><h3 id="概括-2"><a href="#概括-2" class="headerlink" title="概括"></a>概括</h3><table>
<thead>
<tr>
<th>构造</th>
<th>风格</th>
</tr>
</thead>
<tbody><tr>
<td>声明（模块、类、包、接口）</td>
<td><code>lower_snake_case</code></td>
</tr>
<tr>
<td>实例名称</td>
<td><code>lower_snake_case</code></td>
</tr>
<tr>
<td>信号（网络和端口）</td>
<td><code>lower_snake_case</code></td>
</tr>
<tr>
<td>变量、函数、任务</td>
<td><code>lower_snake_case</code></td>
</tr>
<tr>
<td>命名代码块</td>
<td><code>lower_snake_case</code></td>
</tr>
<tr>
<td>`定义宏</td>
<td><code>ALL_CAPS</code></td>
</tr>
<tr>
<td>参数化模块、类和接口的可调参数</td>
<td><code>UpperCamelCase</code></td>
</tr>
<tr>
<td>常数</td>
<td><code>ALL_CAPS</code>或者<code>UpperCamelCase</code></td>
</tr>
<tr>
<td>枚举类型</td>
<td><code>lower_snake_case_e</code></td>
</tr>
<tr>
<td>其他 typedef 类型</td>
<td><code>lower_snake_case_t</code></td>
</tr>
<tr>
<td>枚举值名称</td>
<td><code>UpperCamelCase</code></td>
</tr>
</tbody></table>
<h3 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h3><p><em><strong>使用项目包文件中的参数声明全局常量。</strong></em></p>
<p>在这种情况下，<strong>常量</strong>不同于参数化模块、类等对象的可调参数。</p>
<p>显式声明常量的类型。</p>
<p>声明常量时：</p>
<ul>
<li>在一个包内使用<code>parameter</code>。</li>
<li>在模块或类中使用<code>localparam</code>.</li>
</ul>
<p>定义常量的首选方法是声明 a<code>package</code>并将所有常量声明<code>parameter</code>为该包中的 a。如果常量仅在一个文件中使用，则可以将它们定义在该文件中而不是单独的包中。</p>
<p>在项目的主包中定义项目范围的常量。</p>
<p>其他包也可以用自己的<code>parameter</code>常量声明，以方便创建可以在许多项目中重复使用的 IP。</p>
<p>所有不可变常量的首选命名约定是使用<code>ALL_CAPS</code>，但有时使用<code>UpperCamelCase</code>可能被认为更自然。</p>
<table>
<thead>
<tr>
<th>常量类型</th>
<th>风格偏好</th>
<th>对话</th>
</tr>
</thead>
<tbody><tr>
<td>`定义</td>
<td><code>ALL_CAPS</code></td>
<td>真正恒定</td>
</tr>
<tr>
<td>模块参数</td>
<td><code>UpperCamelCase</code></td>
<td>真正可以通过实例化修改，而不是恒定的</td>
</tr>
<tr>
<td>派生的本地参数</td>
<td><code>UpperCamelCase</code></td>
<td>虽然没有直接修改，但仍然跟踪模块参数</td>
</tr>
<tr>
<td>可调局部参数</td>
<td><code>UpperCamelCase</code></td>
<td>虽然预计不会在最终 RTL 版本中发生变化，但供设计师用来方便地探索设计空间</td>
</tr>
<tr>
<td>真正的 localparam 常数</td>
<td><code>ALL_CAPS</code></td>
<td>例子<code>localparam OP_JALR = 8'hA0;</code></td>
</tr>
<tr>
<td>枚举成员真常数</td>
<td><code>ALL_CAPS</code></td>
<td>例子<code>typedef enum ... { OP_JALR = 8'hA0;</code></td>
</tr>
<tr>
<td>枚举集成员</td>
<td><code>ALL_CAPS</code>或者<code>UpperCamelCase</code></td>
<td>例子<code>typedef enum ... { ST_IDLE, ST_FRAME_START, ST_DYN_INSTR_READ ...</code>，<code>typedef enum ... { StIdle, StFrameStart, StDynInstrRead...</code>。任意值的集合，可以是任何一种约定。</td>
</tr>
</tbody></table>
<p>常量的单位应该在符号名称中描述，除非常量是无单位的或单位是“位”。例如，<code>FooLengthBytes</code>。</p>
<p>例子：</p>
<p>👍</p>
<pre><code>// package-scope
package my_pkg;

  parameter int unsigned NUM_CPU_CORES = 64;
  // reference elsewhere as my_pkg::NUM_CPU_CORES

endpackage
</code></pre>
<h4 id="参数化对象（模块等）"><a href="#参数化对象（模块等）" class="headerlink" title="参数化对象（模块等）"></a>参数化对象（模块等）</h4><p><em><strong>用于<code>parameter</code>参数化和<code>localparam</code>声明模块范围的常量。在包中，使用<code>parameter</code>.</strong></em></p>
<p>您可以创建参数化模块、类和接口以促进设计重用。</p>
<p><code>parameter</code>在参数化模块的<code>module</code>声明中使用关键字来指示用户在实例化时需要调整哪些参数。所有参数的首选命名约定是 <code>UpperCamelCase</code>. 一些项目可能会选择使用<code>ALL_CAPS</code>来区分可调参数和常量。</p>
<p>声明中的派生参数<code>module</code>应使用<code>localparam</code>. 一个例子如下所示。</p>
<pre><code>module modname #(
  parameter  int Depth  = 2048,         // 8kB default
  localparam int Aw     = $clog2(Depth) // derived parameter
) (
  ...
);

endmodule
</code></pre>
<p>``define<code>并且</code>defparam`永远不应该用于参数化模块。</p>
<p>使用<a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants">包参数</a>通过层次结构而不是参数来传输全局常量。要声明一个范围在特定 SystemVerilog 模块内部的常量，<a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants">请</a><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants">改用<code>localparam</code></a>.</p>
<p>何时使用参数化模块的示例：</p>
<ul>
<li>当一个模块的多个实例将被实例化时，需要通过一个参数来区分。</li>
<li>作为将模块专门用于特定总线宽度的一种方式。</li>
<li>作为记录允许在模块内更改哪些全局参数的一种方式。</li>
</ul>
<p>显式声明参数的类型。</p>
<p>使用参数的类型来帮助限制合法范围。例如<code>int unsigned</code>对于一般的非负整数值，<code>bit</code>对于布尔值。对可调参数值的任何进一步限制必须用断言记录。</p>
<p>可调参数值应始终具有合理的默认值。</p>
<p>如需更多阅读内容，请参阅<a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-884-complex-digital-systems-spring-2005/related-resources/parameter_models.pdf">用于创建参数化模型的新 Verilog-2001 技术</a>。</p>
<h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p><em><strong>宏应该是带下划线的 ALL_CAPITALS。</strong></em></p>
<p>宏应全部为大写字母并带有下划线。</p>
<p><strong>全局定义</strong>是项目中所有源文件共享的头文件中的刻度定义宏。为了减少命名空间冲突，全局定义应以一组相关宏的名称为前缀，后跟一对下划线：</p>
<pre><code>// The following two constants are in the FOO namespace of the
// SN chip.
`define SN_FOO__ALPHA_BETA  5
`define SN_FOO__GAMMA_OMEGA 6
</code></pre>
<p><strong>本地定义</strong>是一个刻度定义的宏，只能在单个本地文件的范围内使用。使用后必须明确未定义，以避免污染全局宏命名空间。为了表明宏仅用于本地范围，宏名称应以单个下划线作为前缀。</p>
<p>为确保本地定义保持本地，请注意不要<code> </code>include<code>在宏定义和</code> <code>undef</code>.</p>
<p>例子：</p>
<pre><code>`define _MAKE_THING(_x) \
    thing i_thing_##_x (.clk(clk), .i(i##_x) .o(o##_x));
`_MAKE_THING(a)
`_MAKE_THING(b)
`_MAKE_THING(c)
`undef _MAKE_THING
</code></pre>
<h3 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h3><p>后缀用于多个地方以指导意图。下表列出了具有特殊含义的后缀。</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>竞技场</th>
<th>意图</th>
</tr>
</thead>
<tbody><tr>
<td><code>_e</code></td>
<td>类型定义</td>
<td>枚举类型</td>
</tr>
<tr>
<td><code>_t</code></td>
<td>类型定义</td>
<td>其他类型定义，包括信号簇</td>
</tr>
<tr>
<td><code>_n</code></td>
<td>信号名称</td>
<td>低电平有效信号</td>
</tr>
<tr>
<td><code>_n</code>, <code>_p</code></td>
<td>信号名称</td>
<td>差分对，低电平有效和高电平有效</td>
</tr>
<tr>
<td><code>_d</code>,<code>_q</code></td>
<td>信号名称</td>
<td>寄存器的输入输出</td>
</tr>
<tr>
<td><code>_q2</code>, <code>_q3</code>, 等</td>
<td>信号名称</td>
<td>流水线版本的信号；<code>_q</code>是一个延迟周期，<code>_q2</code>是两个周期，<code>_q3</code>是三个，等等</td>
</tr>
<tr>
<td><code>_i</code>, <code>_o</code>, <code>_io</code></td>
<td>信号名称</td>
<td>模块输入、输出和双向</td>
</tr>
</tbody></table>
<p>当需要多个后缀时，请使用以下指南：</p>
<ul>
<li>指导后缀加在一起，不被附加<code>_</code> 字符分隔（<code>_ni</code>不<code>_n_i</code>）</li>
<li>如果信号为低电平有效<code>_n</code>将是第一个后缀</li>
<li>如果信号是模块输入/输出，字母将排在最后。</li>
<li><code>_d</code>传播和<code>_q</code>到模块边界不是强制性的。</li>
</ul>
<p>例子：</p>
<p>👍</p>
<pre><code>module simple (
  input        clk_i,
  input        rst_ni,              // Active low reset

  // writer interface
  input [15:0] data_i,
  input        valid_i,
  output       ready_o,

  // bi-directional bus
  inout [7:0]  driver_io,         // Bi directional signal

  // Differential pair output
  output       lvds_po,           // Positive part of the differential signal
  output       lvds_no            // Negative part of the differential signal
);

  logic valid_d, valid_q, valid_q2, valid_q3;
  assign valid_d = valid_i; // next state assignment

  always_ff @(posedge clk or negedge rst_ni) begin
    if (!rst_ni) begin
      valid_q  &lt;= '0;
      valid_q2 &lt;= '0;
      valid_q3 &lt;= '0;
    end else begin
      valid_q  &lt;= valid_d;
      valid_q2 &lt;= valid_q;
      valid_q3 &lt;= valid_q2;
    end
  end

  assign ready_o = valid_q3; // three clock cycles delay

endmodule // simple
</code></pre>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><em><strong>名称枚举类型<code>snake_case_e</code>。命名枚举值<code>ALL_CAPS</code>或 <code>UpperCamelCase</code>.</strong></em></p>
<p>始终<code>enum</code>使用<code>typedef</code>. 必须指定任何枚举类型的存储类型。对于可综合枚举，存储类型必须是 4 状态数据类型（<code>logic</code>而不是<code>bit</code>）。</p>
<p><code>enum</code>不允许使用匿名类型，因为它们使在整个项目和跨项目的其他地方使用该类型变得更加困难。</p>
<p>枚举类型名称应仅包含小写字母数字字符和下划线。您必须在枚举类型名称后面加上<code>_e</code>.</p>
<p>枚举值名称（常量）通常应该是<code>ALL_CAPS</code>，例如， <code>READY_TO_SEND</code>以反映它们的常量性质，尤其是对于真正不可更改的值，例如定义的操作码分配。有时<code>UpperCamelCase</code> 可能是首选，当枚举类型的分配值实际上是设计者不关心的时候，就像状态机值一样。有关如何考虑此建议的讨论，请参阅关于 <a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants">常量的对话。</a></p>
<p>👍</p>
<pre><code>typedef enum logic [7:0] {  // 8-bit opcodes
  OP_JALR = 8'hA0,
  OP_ADDI = 8'h47,
  OP_LDW  = 8'h0B
} opcode_e;
opcode_e op_val;
</code></pre>
<p>👍</p>
<pre><code>typedef enum logic [1:0] {  // A 2-bit enumerated type
  ACC_WRITE,
  ACC_READ,
  ACC_PAUSE
} access_e; // new named type is created
access_e req_access, resp_access;
</code></pre>
<p>👍</p>
<pre><code>typedef enum logic [1:0] {  // A 2-bit enumerated type
  AccWrite,
  AccRead,
  AccPause
} access_e; // new named type is created
access_e req_access, resp_access;
</code></pre>
<p>👎</p>
<pre><code>enum {  // Typedef is missing, storage type is missing.
  Write,
  Read
} req_access, resp_access; // anonymous enum type
</code></pre>
<h3 id="信号命名"><a href="#信号命名" class="headerlink" title="信号命名"></a>信号命名</h3><p><em><strong><code>lower_snake_case</code>命名信号时使用。</strong></em></p>
<p>在这种情况下，<strong>信号</strong>意味着 SystemVerilog 设计中的网络、变量或端口。</p>
<p>信号名称可能包含小写字母数字字符和下划线。</p>
<p>信号名称不应以下划线后跟数字结尾（例如<code>foo_1</code>、<code>foo_2</code>等）。许多综合工具使用该命名约定将总线映射到网络，因此在检查综合网表时，类似命名的网络可能会导致混淆。</p>
<p>保留的<a target="_blank" rel="noopener" href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx13_1/ite_r_verilog_reserved_words.htm">Verilog</a>或 SystemVerilog 关键字永远不能用作名称。</p>
<p>与不同语言互操作时，请注意不要使用其他语言的关键字。</p>
<h4 id="使用描述性名称"><a href="#使用描述性名称" class="headerlink" title="使用描述性名称"></a>使用描述性名称</h4><p><em><strong>名称应描述信号的用途。</strong></em></p>
<p>使用整个单词。除非在最常见的地方，否则避免使用缩写词和缩写词。倾向于描述性的信号名称而不是简洁。</p>
<h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><p>使用通用前缀来标识一起操作的信号组。例如，AXI-S 接口的所有元素都将共享一个前缀：<code>foo_valid</code>、、 <code>foo_ready</code>和<code>foo_data</code>。</p>
<p>此外，对于具有多个时钟的任何模块，应使用前缀清楚地标记哪个信号在哪个时钟组中。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#clocks">时钟域部分。</a></p>
<p>例子：</p>
<ul>
<li>与控制 blockram 相关的信号可能共享一个<code>bram_</code>前缀。</li>
<li>同步的信号<code>clk_dram</code>而不<code>clk</code>应该共享<code>dram_</code>前缀。</li>
</ul>
<p>代码示例：</p>
<p>👍</p>
<pre><code>module fifo_controller (
  input         clk_i,
  input         rst_ni,

  // writer interface
  input [15:0]  wr_data_i,
  input         wr_valid_i,
  output        wr_ready_o,

  // reader interface
  output [15:0] rd_data_o,
  output        rd_valid_o,
  output [7:0]  rd_fullness_o,
  input         rd_ack_i,

  // memory interface:
  output [7:0]  mem_addr_o,
  output [15:0] mem_wdata_o,
  output        mem_we_o,
  input  [15:0] mem_rdata_i
);
</code></pre>
<p>这种命名约定使得使用简单且一致的规则将端口名称映射到相似的信号名称变得更加容易。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#hierarchical-consistency">分层一致性部分。</a></p>
<h4 id="层次一致性"><a href="#层次一致性" class="headerlink" title="层次一致性"></a>层次一致性</h4><p><em><strong>同一信号在层次结构的任何级别都应具有相同的名称。</strong></em></p>
<p>连接到实例端口的信号应与该端口具有相同的名称。通过以这种方式进行，直接连接的信号应该在任何层次结构级别保持相同的名称。</p>
<p>此约定的例外情况是预期的，例如：</p>
<ul>
<li>将端口连接到信号数组的元素时。</li>
<li>将通用端口名称映射到更特定于设计的名称时。例如，两个通用块，一个带有<code>host_bus</code>端口，一个带有 <code>device_bus</code>端口，可以通过<code>foo_bar_bus</code>信号连接。</li>
</ul>
<p>在每种例外情况下，应注意使端口名称到信号名称的映射尽可能明确和一致。</p>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p><em><strong>所有时钟信号必须以 开头<code>clk</code>。</strong></em></p>
<p>设计的主系统时钟必须命名为<code>clk</code>。可以使用 <code>clk</code>与模块中的大部分逻辑同步的默认时钟来表示。</p>
<p>如果一个模块包含多个时钟，则非系统时钟的时钟应使用唯一标识符命名，并以<code>clk_</code>前缀开头。例如：<code>clk_dram</code>、<code>clk_axi</code>等。请注意，此前缀将用于标识该时钟域中的其他信号。</p>
<h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><p><em><strong>复位是低电平有效和异步的。默认名称是<code>rst_n</code>.</strong></em></p>
<p>芯片范围内的所有复位都定义为低电平有效和异步。因此，它们被定义为与相关标准单元寄存器的异步复位输入相关联。</p>
<p>默认名称是<code>rst_n</code>. 如果必须通过时钟来区分它们，则时钟名称应包含在重置名称中，如<code>rst_domain_n</code>.</p>
<p>SystemVerilog 允许以下任何一种语法风格，但风格指南更喜欢前者。</p>
<pre><code>// preferred
always_ff @(posedge clk or negedge rst_n) begin
  if (!rst_n) begin
    q &lt;= 1'b0;
  end else begin
    q &lt;= d;
  end
end

// legal but not preferred
always_ff @(posedge clk, negedge rst_n) begin
  if (!rst_n) begin
    q &lt;= 1'b0;
  end else begin
    q &lt;= d;
  end
end
</code></pre>
<h2 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h2><h3 id="首选-SystemVerilog-构造"><a href="#首选-SystemVerilog-构造" class="headerlink" title="首选 SystemVerilog 构造"></a>首选 SystemVerilog 构造</h3><p>使用这些 SystemVerilog 结构而不是它们的 Verilog-2001 等效结构：</p>
<ul>
<li><code>always_comb</code>是必需的<code>always @*</code>。</li>
<li><code>logic</code>优于<code>reg</code>和<code>wire</code>。</li>
<li>顶级<code>parameter</code>声明优于<code> </code>define`全局声明。</li>
</ul>
<h3 id="包依赖"><a href="#包依赖" class="headerlink" title="包依赖"></a>包依赖</h3><p><em><strong>包不能有循环依赖。</strong></em></p>
<p>包文件可能依赖于其他包文件中的常量和类型，但不能有任何循环依赖。也就是说：如果包 A 依赖于包 B 中的常量，则包 B 不能依赖包 A 中的任何内容。虽然 SystemVerilog 语言规范允许循环依赖，但它们的使用可能会破坏某些工具。</p>
<p>例如：</p>
<pre><code>package foo;

  // Package "bar" must not depend on anything in "foo":
  parameter int unsigned PageSizeBytes = 16 * bar::Kibi;

endpackage
</code></pre>
<h3 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h3><p><em><strong>使用 Verilog-2001 全端口声明样式，并使用以下格式。</strong></em></p>
<p>使用 Verilog-2001 组合端口和 I/O 声明样式。不要使用 Verilog-95 列表样式。模块语句中的端口声明应完整声明端口名称、类型和方向。</p>
<p>左括号应与模块声明在同一行，第一个端口应在下一行声明。</p>
<p>右括号应该在它自己的行中，在第 0 列中。</p>
<p>模块声明的缩进遵循两个空格缩进的标准缩进规则。</p>
<p>时钟端口必须首先在端口列表中声明，然后是任何和所有复位输入。</p>
<p>无参数示例：</p>
<p>👍</p>
<pre><code>module foo (
  input              clk_i,
  input              rst_ni,
  input [7:0]        d_i,
  output logic [7:0] q_o
);
</code></pre>
<p>带参数的示例：</p>
<p>👍</p>
<pre><code>module foo #(
  parameter int unsigned Width = 8,
) (
  input                    clk_i,
  input                    rst_ni,
  input [Width-1:0]        d_i,
  output logic [Width-1:0] q_o
);
</code></pre>
<p>不要使用 Verilog-95 样式：</p>
<p>👎</p>
<pre><code>// WRONG:
module foo(a, b, c d);
input wire [2:0] a;
output logic b;
...
</code></pre>
<h3 id="模块实例化"><a href="#模块实例化" class="headerlink" title="模块实例化"></a>模块实例化</h3><p><em><strong>使用命名端口来完全指定所有实例化。</strong></em></p>
<p>将信号连接到端口以进行实例化时，请使用命名端口样式，如下所示：</p>
<pre><code>my_module i_my_instance (
  .clk_i (clk_i),
  .rst_ni(rst_ni),
  .d_i   (from_here),
  .q_o   (to_there)
);
</code></pre>
<p>如果端口和连接信号具有相同的名称，您可以使用 <code>.port</code>语法（不带括号）来表示连接。例如：</p>
<pre><code>my_module i_my_instance (
  .clk_i,
  .rst_ni,
  .d_i   (from_here),
  .q_o   (to_there)
);
</code></pre>
<p>所有声明的端口都必须存在于实例化块中。未连接的输出必须明确写为无连接（例如：） <code>.output_port()</code>，未使用的输入必须明确接地（例如<code>.unused_input_port(8'd0)</code>：）</p>
<p><code>.*</code>不允许。</p>
<p>不要使用位置参数将信号连接到端口。</p>
<p>按照与模块中定义的顺序相同的顺序实例化端口。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#tabular-alignment">以表格样式</a>对齐端口表达式。不要在最长端口名称的左括号前包含空格。不要在左括号之后或包含端口表达式的右括号之前包含空格。</p>
<p>👎</p>
<pre><code>mod u_mod(
  .clk_i,
  .rst_ni,

  // Not allowed: avoid leading/trailing whitespace in expressions.
  .sig_1_i( sig_1 ),
  .sig_2_i( sig_2 )
);

mod u_mod(
  .clk_i,
  .rst_ni,

  .short_sig_i                       (sig_1),
  // Not allowed: avoid whitespace between the longest signal name and the opening parenthesis.
  .a_very_long_signal_name_indeed_i  (sig_2)
);
</code></pre>
<p><em><strong>对所有实例使用命名参数。</strong></em></p>
<p>参数化实例时，使用命名参数样式指定参数。一个例外是，如果只有一个参数是显而易见的，例如寄存器宽度，那么实例化可以是隐式的。</p>
<p>模块实例化的缩进遵循两个空格缩进的标准缩进规则。</p>
<pre><code>my_module #(
  .Height(5),
  .Width(10)
) my_module (
  // ...
);

my_reg #(16) my_reg0 (
  .clk_i,
  .rst_ni,
  .d_i   (data_in),
  .q_o   (data_out)
);
</code></pre>
<p>不要在位置上指定参数，除非只有一个参数并且该参数的意图很明显，例如寄存器实例的宽度。</p>
<p>不要使用<code>defparam</code>.</p>
<p><em><strong>不要递归地实例化。</strong></em></p>
<p>模块可能不会递归地实例化自己。</p>
<h3 id="常数-1"><a href="#常数-1" class="headerlink" title="常数"></a>常数</h3><p><em><strong>建议使用符号命名的常量而不是原始数字。</strong></em></p>
<p>尝试为常用的常量提供符号名称，而不是重复输入原始数字。</p>
<p>局部常量应始终使用<code>localparam</code>.</p>
<p>全局常量应始终在单独的文件<code>.vh</code>或<code>.svh</code>包含文件中声明。</p>
<p>对于 SystemVerilog 代码，应始终将全局常量声明为包参数。对于 Verilog-2001 兼容代码，不支持顶级参数，而<code> </code>define`必须使用宏。</p>
<p>将常量的单位作为后缀包含在常量的符号名称中。此规则的例外是对于本质上无单位的常量，或者如果常量描述的是默认单位类型“位”。</p>
<p>例子：</p>
<pre><code>localparam int unsigned INTERFACE_WIDTH = 64;  // Bits
localparam int unsigned INTERFACE_WIDTH_BYTES = (INTERFACE_WIDTH + 7) / 8;
localparam int unsigned INTERFACE_WIDTH_64B_WORDS = (INTERFACE_WIDTH + 63) / 64;
localparam int unsigned IMAGE_WIDTH_PIXELS = 640;
localparam int unsigned MEGA = 1000 * 1000;  // Unitless
localparam int unsigned MEBI = 1024 * 1024;  // Unitless
localparam int unsigned SYSTEM_CLOCK_HZ = 200 * MEGA;
</code></pre>
<h3 id="信号宽度"><a href="#信号宽度" class="headerlink" title="信号宽度"></a>信号宽度</h3><p><em><strong>注意信号宽度。</strong></em></p>
<h4 id="始终明确数字文字的宽度。"><a href="#始终明确数字文字的宽度。" class="headerlink" title="始终明确数字文字的宽度。"></a>始终明确数字文字的宽度。</h4><p>例子：</p>
<p>👍</p>
<pre><code>localparam logic [3:0] bar = 4'd4;

assign foo = 8'd2;
</code></pre>
<p>👎</p>
<pre><code>localparam logic [3:0] bar = 4;

assign foo = 2;
</code></pre>
<p>例外：</p>
<ul>
<li>使用参数化宽度时，可以简单地使用<code>1'b1</code>（例如，在递增时）而不是像 <code>{{(Bus_width-1){1'b0}}, 1'b1}</code>. 或者，它可以写成<code>Bus_width'(1)</code>.</li>
<li>使用 ‘0 构造来创建自动正确大小的零是可以接受的。</li>
<li>分配给整数变量（例如 byte、shortint、int、integer 和 longint）的文字不需要明确的宽度。</li>
</ul>
<h4 id="模块实例上的端口连接必须始终正确匹配宽度。"><a href="#模块实例上的端口连接必须始终正确匹配宽度。" class="headerlink" title="模块实例上的端口连接必须始终正确匹配宽度。"></a>模块实例上的端口连接必须始终正确匹配宽度。</h4><p>建议尽可能使用显式宽度，而不是依赖 Verilog 的隐式零扩展和截断操作。</p>
<p>例子：</p>
<p>👍</p>
<pre><code>my_module i_module (
  .thirty_two_bit_input({16'd0, sixteen_bit_word})
);
</code></pre>
<p>👎</p>
<pre><code>my_module i_module (
  // Incorrectly implicitly extends from 16 bit to 32 bit
  .thirty_two_bit_input(sixteen_bit_word)
);
</code></pre>
<h4 id="不要在布尔上下文中使用多位信号。"><a href="#不要在布尔上下文中使用多位信号。" class="headerlink" title="不要在布尔上下文中使用多位信号。"></a>不要在布尔上下文中使用多位信号。</h4><p>与其让布尔运算和 if 表达式将多位信号简化为单个位，不如将多位信号显式与 0 进行比较。隐式转换可以隐藏细微的逻辑错误。</p>
<p>例子;</p>
<p>👍</p>
<pre><code>logic [3:0] a, b;
logic out;

assign out = (a != '0) &amp;&amp; (b == '0);

always_comb begin
  if (a != '0)
    ...
  else
    ...
end
</code></pre>
<p>👎</p>
<pre><code>logic [3:0] a, b;
logic out;

// Incorrect because it implicitly converts 4-bit signals to 1-bit before AND.
// Also, !b is different from ~b and can be hard to catch.
assign out = a &amp;&amp; !b;

// Incorrect use of a multi-bit signal in an if expression
always_comb begin
  if (a)
    ...
  else
    ...
end
</code></pre>
<h4 id="位切片"><a href="#位切片" class="headerlink" title="位切片"></a>位切片</h4><p>仅当意图引用位向量的一部分时才使用位切片运算符。</p>
<p>例子：</p>
<p>👍</p>
<pre><code>logic [7:0] a, b;
logic [6:0] c;

assign a = 8'd7;       // good

assign a[7:1] = 7'd5;  // good - it's partial assignment.
assign a = b;          // good - the parser would warn on width mismatch.
</code></pre>
<p>👎</p>
<pre><code>logic [7:0] a, b;

assign a[7:0] = 8'd7;  // BAD - redundant and can mask linter warnings.
assign a = b[7:0];     // BAD - redundant and masks linter warnings.
</code></pre>
<h4 id="处理宽度溢出"><a href="#处理宽度溢出" class="headerlink" title="处理宽度溢出"></a>处理宽度溢出</h4><p>注意移位操作，它会产生比操作数更宽的结果。位选择和连接可能比移动一个恒定量更清楚。</p>
<p>由于进位，加法和否定运算产生的结果比操作数宽一位。关于匹配宽度的规则的一个允许的例外是默默地放弃继续分配。</p>
<p>例子：</p>
<pre><code>logic [3:0] cnt_d, cnt_q;
assign cnt_d = cnt_q + 4'h1;
</code></pre>
<p>或者您可以通过使用大小转换来明确表示放弃进位。</p>
<pre><code>assign cnt_d = 4'(cnt_q + 4'h1);
</code></pre>
<h3 id="阻塞和非阻塞赋值"><a href="#阻塞和非阻塞赋值" class="headerlink" title="阻塞和非阻塞赋值"></a>阻塞和非阻塞赋值</h3><p><em><strong>顺序逻辑必须使用非阻塞赋值。组合块必须使用块分配。</strong></em></p>
<p>切勿在块声明中混合赋值类型。</p>
<p>顺序块（在时钟沿锁存状态的块）必须专门使用非块分配，如下面的顺序逻辑部分所定义。</p>
<p>纯组合块必须专门使用块分配。</p>
<p>这是 Cliff Cumming 的<a target="_blank" rel="noopener" href="http://www.ece.cmu.edu/~ece447/s13/lib/exe/fetch.php?media=synth-verilog-cummins.pdf">Verilog 黄金法则之一</a>。</p>
<h3 id="延迟建模"><a href="#延迟建模" class="headerlink" title="延迟建模"></a>延迟建模</h3><p><em><strong>不要<code>#delay</code>在可综合的设计模块中使用。</strong></em></p>
<p>可综合设计模块必须围绕零延迟仿真方法进行设计。不允许使用<code>#delay</code>包括 在内的所有形式。<code>#0</code></p>
<p>有关详细信息，请参阅 Cliff Cumming 的<a target="_blank" rel="noopener" href="http://www.sunburst-design.com/papers/CummingsSNUG2002Boston_NBAwithDelays.pdf">Verilog Nonblocking Assignments With Delays, Myths &amp; Mysteries</a> 。</p>
<h3 id="顺序逻辑（锁存器）"><a href="#顺序逻辑（锁存器）" class="headerlink" title="顺序逻辑（锁存器）"></a>顺序逻辑（锁存器）</h3><p><em><strong>不鼓励使用锁存器 - 尽可能使用触发器。</strong></em></p>
<p>除非绝对必要，否则使用触发器/寄存器而不是锁存器。</p>
<p>如果必须使用锁存器，请使用<code>always_latch</code>over<code>always</code>并使用非阻塞赋值 ( <code>&lt;=</code>)。永远不要使用阻塞赋值 ( <code>=</code>)。</p>
<h3 id="顺序逻辑（寄存器）"><a href="#顺序逻辑（寄存器）" class="headerlink" title="顺序逻辑（寄存器）"></a>顺序逻辑（寄存器）</h3><p><em><strong>使用标准格式声明顺序块。</strong></em></p>
<p>在顺序的 always 块中，仅使用非阻塞赋值 ( <code>&lt;=</code>)。永远不要使用阻塞赋值 ( <code>=</code>)。</p>
<p>将寄存器的阻塞和非阻塞分配混合在一起的设计模拟不正确，因为一些模拟器将始终块中的一些阻塞分配处理为在单独的模拟事件中作为非阻塞分配发生。这个过程使一些信号跳跃寄存器，可能导致完全的质子反转。那很糟。</p>
<p>状态分配的顺序语句应仅包含重置值和状态分配的下一个状态，使用单独的仅组合块来生成该下一个状态值。</p>
<p>将实现一个初始值为“0xAB”的正确实现的 8 位寄存器：</p>
<p>👍</p>
<pre><code>logic foo_en;
logic [7:0] foo_q, foo_d;

always_ff @(posedge clk or negedge rst_ni) begin
  if (!rst_ni) begin
    foo_q &lt;= 8'hab;
  end else if (foo_en) begin
    foo_q &lt;= foo_d;
  end
end
</code></pre>
<p>不允许对同一位进行多个非阻塞分配。</p>
<p>例子：</p>
<p>👎</p>
<pre><code>if (cond1) begin
  abc &lt;= 4'h1;
end

if (cond2) begin
  abc &lt;= 4'h2;
end
</code></pre>
<p>如果 cond1 和 cond2 都为真，则 Verilog 标准规定第二个赋值将生效，但这是违反样式的。</p>
<p>即使<code>cond1</code>和<code>cond2</code>是互斥的，也要把第二个<code>if</code>变成 <code>else if</code>.</p>
<p>例外：可以先设置默认值，然后设置特定值。但是，最好在具有显式阻塞分配的单独组合块中完成这项工作。</p>
<p>例子：</p>
<pre><code>always_ff @(posedge clk or negedge rst_ni) begin
  if (!rst_ni) begin
    state_q &lt;= StIdle;
  end else begin
    state_q &lt;= state_d;
  end
end

always_comb begin
  state_d = state_q;    // default assignment next state is present state
  unique case (state_q)
    StIdle: state_d = StInit;       // Idle State move to Init
    StInit: begin                   // Initialize calculation
      if (conditional) begin
        state_d = StIdle;
      end else begin
        state_d = StCalc;
      end
    end
    StCalc: begin                   // Perform calculation
      if (conditional) begin
        state_d = StResult;
      end
    end
    StResult: state_d = Idle;
    default: ;
  endcase
end
</code></pre>
<p>保持顺序块中的工作简单。如果顺序块变得足够复杂，请考虑将组合逻辑拆分为单独的组合 ( <code>always_comb</code>) 块。理想情况下，顺序块应该只包含一个寄存器实例，可能带有一个加载使能或一个增量。</p>
<h3 id="不在乎（X‘s）"><a href="#不在乎（X‘s）" class="headerlink" title="不在乎（X‘s）"></a>不在乎（<code>X</code>‘s）</h3><p><em><strong><code>X</code>强烈建议不要在 RTL 代码中使用文字。在任何情况下， RTL 都不得断言<code>X</code>对综合表示“不关心”。为了标记和检测无效条件，而不是分配和传播<code>X</code>值，设计应该完全定义所有信号值并广泛使用 SVA 来指示无效条件。</strong></em></p>
<p>如果不严格控制，<code>X</code>在 RTL 中使用分配来标记无效或无关条件可能会导致仿真/综合不匹配。</p>
<p><strong>鼓励广泛使用 SVA</strong> ，而不是分配和传播<code>X</code>以标记和检测无效条件。这种设计实践的额外好处是：</p>
<ul>
<li><code>X</code>正确传播条件不需要特殊的代码样式，</li>
<li>系统地减少了意外引入模拟/综合失配的机会，</li>
<li>模拟会很快失败，并且需要更少的信号回溯来解决根本原因错误，</li>
<li>在某些情况下，可以使用形式属性验证 (FPV) 来证明这些 SVA 是否始终能够得到满足，</li>
<li>在安全上下文中，需要确定性/定义的行为，即使对于非法/无效/无法访问的输入组合（有时更简洁地表述为“对于安全关键设计，没有无关紧要”）。</li>
</ul>
<p>这里提出的解决方案与Don Mills在<a target="_blank" rel="noopener" href="http://www.lcdm-eng.com/papers/snug04_assertiveX.pdf">“Being Assertive With Your X”</a>中提出的方法有相似之处 。</p>
<p>请注意，尽管 don’t cares 可用于指示综合工具可能的优化机会，但逻辑缩减的收益是否足以超过使用<code>X</code>文字可能带来的综合不匹配问题（尤其是使用当今技术中可用的门数）。</p>
<h4 id="捕获使用无效值的错误"><a href="#捕获使用无效值的错误" class="headerlink" title="捕获使用无效值的错误"></a>捕获使用无效值的错误</h4><p>对于内部生成的可能无效（但未驱动到<code>X</code>）的信号并用于触发某些操作（例如寄存器写使能），建议添加断言以检查当使能为真时，信号有效。当意外使用无效值时，这会触发简单的故障诊断。</p>
<pre><code>logic reg_addr;
logic reg_wr_en;

// internal logic which generates reg_addr/reg_wr_en reg_en_addr will never
// be X but must be ignored if reg_wr_en == 0
assign reg_addr = ...
assign reg_wr_en = ...

...

// trigger some specific action when a certain register is written
logic special_reg_en;

assign special_reg_en = (reg_addr == SPECIAL_REG_ADDR) &amp; reg_wr_en;

// Aim to keep RHS of implication as broad as possible
`ASSERT(NoSpecialRegEnWithoutRegEn, special_reg_en |-&gt; reg_wr_en);
</code></pre>
<p>其中值及其有效性信号由 DV 环境生成，该环境将驱动<code>X</code>无效信号``ASSERT_KNOWN`就足够了。</p>
<pre><code>module mymod (
  input [7:0] external_addr_i,
  input       external_wr_en_i
);

  logic special_action_en;

  assign special_action_en =
      (external_addr_i == SPECIAL_ADDR) &amp; external_wr_en_i;

  `ASSERT_KNOWN(special_action_en)

endmodule
</code></pre>
<h4 id="案例陈述和三元组的具体指导"><a href="#案例陈述和三元组的具体指导" class="headerlink" title="案例陈述和三元组的具体指导"></a>案例陈述和三元组的具体指导</h4><p>为了符合这种风格，RTL 必须<code> </code>ASSERT_KNOWN<code>对所有模块输出进行断言，但可能隐含</code>X`在仿真开始时的信号除外，例如 FIFO、SRAM 或寄存器文件输出。</p>
<pre><code>module mymod (
  input        ina_i,
  input        inb_i,
  output logic out_o
);
  assign out_o = ina_i ^ inb_i;
  `ASSERT_KNOWN(OutKnown_A, out_o, clk_i, !rst_ni)
endmodule : mymod
</code></pre>
<p>此外，鼓励将断言添加到形成 case 语句、三元组或 if/else 语句的条件的信号中。断言样式由设计者自行决定，范围可以从简单<code> </code>ASSERT_KNOWN` 断言到功能齐全的断言，如以下示例所示：</p>
<pre><code>typedef enum logic [1:0] {mode0, mode1, mode2} state_e;
state_e sel;

// encouraged
`ASSERT_KNOWN(SelKnown_A, sel)
always_comb begin
  out0 = '0;
  out1 = '0;
  unique case (sel)
    mode1: out0 = foo;
    mode2: out1 = bar;
    default: ;
  endcase
end

// optional, but more explicit
// not always applicable
`ASSERT(MainFsmCase_A, sel inside {mode0, mode1, mode2}, clk_i, !rst_ni)
always_comb begin
  out0 = '0;
  out1 = '0;
  unique case (sel)
    mode1: out0 = foo;
    mode2: out1 = bar;
    default: ;
  endcase
end
</code></pre>
<p>在三元语句的上下文中，鼓励使用以下示例：</p>
<pre><code>// encouraged
`ASSERT_KNOWN(ModeKnown_A, mode_i, clk_i, !rst_ni)
`ASSERT_KNOWN(LenKnown_A, len_i, clk_i, !rst_ni)
// assign '0 for all other combinations
assign val = (mode_i == ENC)                    ? 8'h01 :
             (mode_i == DEC &amp;&amp; len_i == LEN128) ? 8'h36 :
             (mode_i == DEC &amp;&amp; len_i == LEN192) ? 8'h80 :
             (mode_i == DEC &amp;&amp; len_i == LEN256) ? 8'h40 : 8'h00;

// optional, but more explicit
`ASSERT(ValSelValid_A, mode_i == ENC || mode_i == DEC &amp;&amp;
    len_i inside {LEN128, LEN192, LEN256}, clk_i, !rst_ni)
// using one of the valid outputs for other combinations (saves logic)
assign val = (mode_i == ENC)                    ? 8'h01 :
             (mode_i == DEC &amp;&amp; len_i == LEN128) ? 8'h36 :
             (mode_i == DEC &amp;&amp; len_i == LEN192) ? 8'h80 :
             (mode_i == DEC &amp;&amp; len_i == LEN256) ? 8'h40 : 8'h01;
</code></pre>
<p>请注意，在某些情况下，输入到 case 或 ternary 可能是<code>X</code> 但仅在无关紧要的情况下，因为输出将被忽略，因为未设置一些符合输入的有效信号。例如，输入可以直接来自存储器或来自 DV 环境驱动的顶级输入<code>X</code>。在这些情况下， plain``ASSERT_KNOWN`将不起作用，并且使用具有某些限定有效的断言是合适的：</p>
<pre><code>`ASSERT(AddrKnownIfValid, addr_valid |-&gt; !$isunknown(addr))
always_comb begin
  out = '0
  unique case (addr[1:0])
    ConstAddr1: out = foo;
    ConstAddr2: out = bar;
    default:    out = baz;
  endcase
end
</code></pre>
<p>目的应该是使合格的有效信号尽可能广泛，而不是缩小<code>X</code>检查范围超出要求：</p>
<p>👎</p>
<pre><code>`ASSERT(AddrKnownIfValid,
  addr_valid &amp; internal_condition_1 &amp; internal_condition_2 |-&gt;
  !$isunknown(addr))
</code></pre>
<h4 id="动态数组索引"><a href="#动态数组索引" class="headerlink" title="动态数组索引"></a>动态数组索引</h4><p>需要注意的是，动态数组索引操作可以隐式导致 <code>X</code>. 如果可能，应通过将索引数组对齐到 2 的幂或通过在索引操作周围添加保护 if 语句来避免这种情况。这些解决方案在以下示例中进行了说明。</p>
<p>👎</p>
<pre><code>logic selected;
logic [3:0] idx;
logic [11:0] foo; // problematic

assign foo = {12'b1010_1111_0000};
assign selected = foo[idx];
</code></pre>
<p>👍</p>
<pre><code>logic selected;
logic [3:0] idx;
logic [15:0] foo; // aligned to powers of two

assign foo = {4'b0000, 12'b1010_1111_0000};
assign selected = foo[idx];
</code></pre>
<p>👍</p>
<pre><code>logic selected;
logic [3:0] idx;
logic [11:0] foo;

assign foo = {12'b1010_1111_0000};

// guarding if statement
assign selected = (idx &lt; $bits(foo)) ? foo[idx] : 1'b0;
</code></pre>
<h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p><em><strong>避免敏感度列表，并使用一致的分配类型。</strong></em></p>
<p>用于<code>always_comb</code>SystemVerilog 组合块。<code>always @*</code>如果仅支持 Verilog-2001，则使用。永远不要明确声明组合逻辑的敏感性列表。</p>
<p>在可行的情况下首选分配语句。</p>
<p>例子：</p>
<pre><code>assign final_value = xyz ? value_a : value_b;
</code></pre>
<p>如果需要 case 语句，请将其包含在自己的<code>always_comb</code>块中。</p>
<p>可综合的组合逻辑块应该只使用阻塞赋值。</p>
<p>不要使用三态逻辑（<code>Z</code>state）来完成多路复用等片上逻辑。</p>
<p>不要在函数内部推断锁存器，因为这可能会导致模拟/综合不匹配。</p>
<h3 id="案例陈述"><a href="#案例陈述" class="headerlink" title="案例陈述"></a>案例陈述</h3><p><em><strong>避免修改大小写的编译指示。<code>unique case</code>是最佳实践。始终定义默认情况。</strong></em></p>
<p>永远不要使用 the<code>full_case</code>或<code>parallel_case</code>pragma。这些 pragma 很容易导致综合仿真不匹配。</p>
<p>下面是一个符合样式的完整 case 语句示例：</p>
<pre><code>always_comb begin
  unique casez (select)
    3'b000: operand = accum0 &gt;&gt; 0;
    3'b001: operand = accum0 &gt;&gt; 1;
    3'b010: operand = accum1 &gt;&gt; 0;
    3'b011: operand = accum1 &gt;&gt; 1;
    3'b1??: operand = regfile[select[1:0]];
    default: operand = '0; // assign a default
  endcase
end
</code></pre>
<p>建议在所有 case 语句之前使用<code>unique</code>前缀，因为它会创建可以捕获某些错误的模拟断言。在某些情况下，<code>priority</code> 可以使用 代替<code>unique</code>，但在这种情况下，级联三元结构应该是表示优先级编码器的首选方式，因为它们是优先级编码器的更易读的表示。</p>
<p>一定要<code>unique case</code>正确使用。特别要确保：</p>
<ul>
<li><strong>始终</strong>包含一个<code>default:</code>语句以避免意外推断闩锁，即使涵盖了所有情况。在模拟中，计算结果为的 case 表达式将不匹配任何 case 并且将充当锁存器，如果未指定默认值，则会导致与综合不同的行为。<code>X</code></li>
<li>如上例所示，如果在 case 语句之前没有给出默认赋值，则在一个 case 项中分配的任何变量都必须在所有 case 项中分配，包括<code>default:</code>. 不这样做可能会导致模拟综合不匹配，如<a target="_blank" rel="noopener" href="http://www.lcdm-eng.com/papers/snug12_Paper_final.pdf">Don Mills 的论文</a>中所述。</li>
</ul>
<p>以下是一个不同的示例，显示了一个符合样式的 case 语句变体，该变体经常用于描述有限状态机的下一个状态逻辑。与前面的示例不同的是，默认分配放在<code>unique case</code>块之前，因此可以在下面的个别情况下省略常见的分配。如果不是在 case 语句之前进行常见的默认分配，则必须在所有情况下为所有变量分配一个值，<code>default:</code>以防止模拟-综合不匹配。</p>
<pre><code>always_comb begin
  // common default assignments
  state_d = state_q;
  outa = 1'b0;
  outb = 1'b0;
  outc = 1'b0;

  unique case (state_q)
    Idle: begin
      state_d = Work;
      outa = in0;
    end
    Work: begin
      state_d = Wait;
      outb = in1;
    end
    Wait: begin
      state_d = Idle;
      outc = in2;
    end
    // always include a default case
    // empty default permissible due to defaults before case block
    default: ;
  endcase
end
</code></pre>
<h4 id="案例项目中的通配符"><a href="#案例项目中的通配符" class="headerlink" title="案例项目中的通配符"></a>案例项目中的通配符</h4><p><code>case</code>如果不需要通配符运算符行为，请使用。<code>case inside</code>如果需要通配符运算符行为，请使用。如果<code>casez</code>需要通配符运算符行为并且需要 Verilog-2001 兼容性，则使用此选项。</p>
<p>在案例项目中表示通配符时，请使用“？” 字符，因为它更清楚地表达了意图。</p>
<p><code>casex</code>不应该使用。<code>casex</code>实现了一个对称通配符运算符，这样一个<code>X</code>in case 表达式可以匹配一个或多个 case 项。 <code>casez</code>仅将高阻抗状态 (<code>Z</code>或<code>?</code>) 视为通配符，并对未驱动的<code>X</code>输入执行完全匹配。虽然这并不能完全解决对称通配符匹配的问题，但意外产生<code>Z</code>输入比<code>X</code>输入更难，因此首选这种形式。 <code>case inside</code>不会将case 表达式<code>X</code>或<code>Z</code>case 表达式视为通配符，因此这种形式优于<code>casez</code>.</p>
<p>参考：</p>
<ul>
<li>Don Mills，<a target="_blank" rel="noopener" href="http://www.lcdm-eng.com/papers/snug12_Paper_final.pdf">又一个闩锁和陷阱纸</a></li>
<li>Clifford Cummings，<a target="_blank" rel="noopener" href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf">full_case parallel_case，Verilog 综合的邪恶双胞胎</a></li>
<li>Clifford Cummings，<a target="_blank" rel="noopener" href="http://www.sunburst-design.com/papers/CummingsSNUG2005Israel_SystemVerilog_UniquePriority.pdf">SystemVerilog 的优先级和独特性</a></li>
<li>Sutherland、Mills 和 Spear，[再次遇到问题：每个工程师都应该知道的 Verilog 和 SystemVerilog 标准中的更多细微之处](<a target="_blank" rel="noopener" href="http://www.lcdm-eng.com/papers/snug07_Verilog">http://www.lcdm-eng.com/papers/snug07_Verilog</a> Gotchas Part2.pdf)</li>
</ul>
<h3 id="生成构造"><a href="#生成构造" class="headerlink" title="生成构造"></a>生成构造</h3><p><em><strong>始终命名您生成的块。</strong></em></p>
<p>使用 generate 构造时，始终明确命名每个生成代码块。命名生成 if 语句的每个可能结果，并命名生成 for 语句的迭代块。</p>
<p>这可确保生成的分层信号名称在不同工具之间保持一致。</p>
<p>生成和所有命名的代码块都应该使用<code>lower_snake_case</code>. 应<code>begin</code>在代码块名称和代码块名称之间放置一个空格。</p>
<p>条件生成构造示例：</p>
<p>👍</p>
<pre><code>if (TypeIsPosedge) begin : posedge_type
  always_ff @(posedge clk) foo &lt;= bar;
end else begin : negedge_type
  always_ff @(negedge clk) foo &lt;= bar;
end
</code></pre>
<p>循环生成构造示例：</p>
<p>👍</p>
<pre><code>for (genvar ii = 0; ii &lt; NumberOfBuses; ii++) begin : my_buses
  my_bus #(.index(ii)) i_my_bus (.foo(foo), .bar(bar[ii]));
end
</code></pre>
<p>不要使用附加<code>begin</code>块包装生成构造。</p>
<p>不要使用生成区域 { <code>generate</code>, <code>endgenerate</code>}。</p>
<h3 id="有符号算术"><a href="#有符号算术" class="headerlink" title="有符号算术"></a>有符号算术</h3><p><em><strong>在使用有符号算术的地方使用可用的有符号算术结构。</strong></em></p>
<p>当需要从无符号转换为有符号时，请使用强制转换<code>signed'</code>运算符（<code>$signed</code>在 Verilog-2001 中）。</p>
<p>如果计算中的任何操作数是无符号的，Verilog 会隐式地将所有操作数转换为无符号并生成警告。如果正确转换了所有无符号变量，则仿真或综合工具不应有任何有符号到无符号的警告。</p>
<p>隐式有符号到无符号转换的示例：</p>
<pre><code>logic signed [7:0]  a;
logic               incr;
logic signed [15:0] sum1, sum2, sum3;
initial begin
  a = 8'sh80;                        // a = -128
  incr = 1'b1;
  sum1 = a + incr;                   // bad:  sum1 = 16'h0081 ( 129)
  sum2 = a + signed'({1'b0, incr});  // good: sum2 = 16'hFF81 (-127)
  sum3 = a + 8'sh01;                 // good: sum3 = sum2 (more straightforward)
end
</code></pre>
<p>在上面的示例中，无符号的事实也<code>incr</code>导致<code>a</code>评估为无符号。该<code>sum1</code>评估令人惊讶，并带有不应忽略的警告标记。</p>
<h3 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h3><p><em><strong>用 .前缀打印的二进制数<code>0b</code>。用 . 前缀打印的十六进制数字<code>0x</code>。不要为十进制数字使用前缀。</strong></em></p>
<p>在为日志文件格式化数字的文本表示时，请明确您包含哪些数据。</p>
<p>使打印数字的基础清晰。只打印不带修饰符的十进制数字。<code>0x</code>对十六进制使用前缀，<code>0b</code>对二进制使用前缀。</p>
<p>单独解码大型结构的各个字段，而不是期望用户手动解码原始值。</p>
<p>👍</p>
<pre><code>$display("0x%0x", some_hex_value);
$display("0b%0b", some_binary_value);
$display("%0d",   some_decimal_value);
</code></pre>
<p>👎</p>
<pre><code>$display("%0x",   some_hex_value);
$display("%0b",   some_binary_value);
$display("0d%0d", some_decimal_value);
</code></pre>
<p>分配常量值时，为了更好的可读性，最好对长度超过 8 的十六进制或二进制位强度使用下划线表示法。除非提高可读性，否则不需要零前缀。以它们通常显示的格式（二进制、十六进制、十进制）声明常量。</p>
<p>👍</p>
<pre><code>logic [15:0] val0, val1, val2;
logic [39:0] addr0, addr1;

always_comb begin
  val0 = 16'h0;
  if (condition1) begin
    val1  = 16'b0010_0011_0000_1101;
    val2  = 16'b0010_1100_0000_0000;
    addr1 = 40'h00_1fc0_0000;
    addr2 = 40'h00_efc0_0000;
  end else begin
    val0  = 16'hffff;
    val1  = 16'b1010_0011_0110_1001;
    val2  = 16'b1110_1100_1111_0110;
    addr1 = 40'h40_8000_0000;
    addr2 = 40'h41_c000_0000;
  end
end
</code></pre>
<h3 id="功能和任务"><a href="#功能和任务" class="headerlink" title="功能和任务"></a>功能和任务</h3><p>以下部分仅适用于可综合 RTL。请参阅用于 DV 使用<a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/DVCodingStyle.md">的设计验证的编码风格指南。</a></p>
<p><em><strong>在可综合的 RTL 中，只要声明了函数，就可以使用函数 <code>automatic</code>。不应使用任务。</strong></em></p>
<p>函数必须在包或模块中声明。一个包适用于函数与包中的其他定义相关的情况，并且可能对多个模块有用（即使它当前仅由一个模块使用）。模块适用于功能与该模块的内部特别相关的情况。</p>
<p>函数的目标应该是在概念上表示一个可重用的组合逻辑块。</p>
<p>必须为所有参数和函数返回值显式声明存储类型。所有类型都必须是 4 态数据类型，或者<code>logic</code>派生自的类型<code>logic</code>（例如适当<code>struct</code>的<code>enum</code>或<code>typedef</code>类型）。</p>
<p>不要在函数参数上使用<code>output</code>、、<code>inout</code>或。<code>ref</code>所有功能都应该只消耗输入并产生一个输出。<code>input</code>是默认值，函数参数不需要。</p>
<p>👎</p>
<pre><code>// - Doesn't have explicit storage type on `a` or `b` or return type
// - `b` being used as `output` argument
// - `input` not required on `a`
function automatic [2:0] foo(input [2:0] a, [2:0] b);
  b = b + 1;
  return a + b;
endfunction
</code></pre>
<p>👎</p>
<pre><code>// - Doesn't have explicit storage type on `a`, `b` or `c`
// - Uses `output` on `c`
// - `input` not required on `a` and `b`
function automatic logic [2:0] foo(input [2:0] a, input [2:0] b, output [2:0] c);
  c = a - b;
  return a + b;
endfunction
</code></pre>
<p>👎</p>
<pre><code>// - Uses 2-state data type `int` for `a`
function automatic logic [2:0] foo(int a, logic [2:0] b);
  return a + b;
endfunction
</code></pre>
<p>👍</p>
<pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);
 return a ^ b;
endfunction
</code></pre>
<p>👍</p>
<pre><code>typedef logic [2:0] bar_t;

typedef struct packed {
  logic [2:0] field;
} baz_t;

function automatic logic [2:0] foo(bar_t a, baz_t b);
  return a + b.field;
endfunction
</code></pre>
<p>应该使用显式<code>return result</code>样式从函数返回数据。不要使用<code>function_name = result</code>样式。</p>
<p>👎</p>
<pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);
  if (a == 3'd2) begin
    foo = b;
  end else begin
    foo = a ^ b;
  end
endfunction
</code></pre>
<p>👍</p>
<pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);
  logic [2:0] result;

  if (a == 3'd2) begin
    result = b;
  end else begin
    result = a ^ b;
  end

  return result;
endfunction
</code></pre>
<p>必须在所有代码路径中分配所有局部变量，通过初始分配或通过使用<code>else</code>and <code>default:</code>for<code>if</code>和 <code>case</code>语句。</p>
<p>👍</p>
<pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);
  logic [2:0] local_var_1;
  logic [2:0] local_var_2;

  local_var_1 = 3'd0;

  if (a == 0) begin
    local_var_1 = 3'd2;
  end

  unique case(b)
    3'd0:    local_var_2 = 3'd1;
    3'd1:    local_var_2 = 3'd3;
    default: local_var_2 = 3'd0;
  endcase

  return local_var_1 + local_var_2;
endfunction
</code></pre>
<p>👎</p>
<pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);
  logic [2:0] local_var_1;
  logic [2:0] local_var_2;

  if (a == 0) begin
    local_var_1 = 3'd2;
  end

  unique case(b)
    3'd0:    local_var_2 = 3'd1;
    3'd1:    local_var_2 = 3'd3;
  endcase

  return local_var_1 + local_var_2;
endfunction
</code></pre>
<h3 id="有问题的语言特征和结构"><a href="#有问题的语言特征和结构" class="headerlink" title="有问题的语言特征和结构"></a>有问题的语言特征和结构</h3><p>这些语言特性被认为是有问题的，除非另有说明，否则不鼓励使用它们：</p>
<ul>
<li>接口。</li>
<li><code>alias</code>声明。</li>
</ul>
<h4 id="浮动起始块"><a href="#浮动起始块" class="headerlink" title="浮动起始块"></a>浮动起始块</h4><p>使用除<code>for</code>循环之外的生成块<code>if</code>，或<code>case</code>生成构造不符合 LRM。虽然某些工具可能会接受这种用法，但本指南禁止这种“裸”生成块。请注意，类似的“顺序块”构造符合 LRM 并被允许。</p>
<p>👎</p>
<pre><code>module foo (
  input bar,
  output foo
);
  begin // illegal generate block
    assign foo = bar;
  end
endmodule
</code></pre>
<h4 id="分层引用"><a href="#分层引用" class="headerlink" title="分层引用"></a>分层引用</h4><p>禁止在可综合的 RTL 代码中使用分层引用。某些综合工具确实支持分层引用，而一些工具会出错，而其他工具可能会默默地忽略它们，这可能会导致仿真/综合不匹配。</p>
<p>一个例外情况是分层引用由宏保护以将它们移除以进行综合，例如，作为 SystemVerilog 断言 (SVA) 的一部分。</p>
<p>👎</p>
<pre><code>module mymod_int (
  input        in0_i,
  input        in1_i,
  input        in2_i,
  output logic out_o
);

  logic int;
  assign int   = in0_i &amp; in1_i;
  assign out_o = in2_i | int;

endmodule

module mymod (
  ...
);

  mymod_int u_mymod_int (
    .in0_i,
    .in1_i,
    .in2_i,
    .out_o
  );

  // Hierarchical references are prohibited in synthesizable RTL code.
  assign int_o = u_mymod_int.int;

endmodule
</code></pre>
<h2 id="设计惯例"><a href="#设计惯例" class="headerlink" title="设计惯例"></a>设计惯例</h2><h3 id="概括-3"><a href="#概括-3" class="headerlink" title="概括"></a>概括</h3><p>本节的主要思想包括：</p>
<ul>
<li>声明所有信号并使用<code>logic</code>：<code>logic foo;</code></li>
<li>打包数组是小端的：<code>logic [7:0] byte;</code></li>
<li>未打包的数组是大端的：<code>byte_t arr[0:N-1];</code></li>
<li>首选注册模块输出。</li>
<li>一致地声明 FSM。</li>
</ul>
<h3 id="声明所有信号"><a href="#声明所有信号" class="headerlink" title="声明所有信号"></a>声明所有信号</h3><p><em><strong>不要依赖推断的网络。</strong></em></p>
<p>所有信号<strong>必须</strong>在使用前显式声明。所有声明的信号都必须指定数据类型。正确的设计不包含推断网络。</p>
<h3 id="用于logic合成"><a href="#用于logic合成" class="headerlink" title="用于logic合成"></a>用于<code>logic</code>合成</h3><p><em><strong>用于<code>logic</code>合成。<code>wire</code>必要时允许。</strong></em></p>
<p>可综合 RTL 中的所有信号都必须根据 4 状态数据类型来实现。这意味着所有信号最终都必须由存储类型为<code>logic</code>. 虽然 SystemVerilog 确实为其他数据原语提供了 4 状态存储（即<code>integer</code>），但这些原语很容易产生误解和误用。</p>
<p>例如：</p>
<p>👍</p>
<pre><code>logic signed [31:0] x_velocity;  // say what you mean: a signed 32-bit integer.
typedef logic [7:0] byte_t;
</code></pre>
<p>👎</p>
<pre><code>bit signed [63:0] stars_in_the_sky;  // 2-state logic doesn't belong in RTL
int grains_of_sand;  // Or wait, did I mean integer?  Easy to confuse!
</code></pre>
<p>允许使用线作为简写来声明网络和执行连续分配。注意不要将连续赋值与初始化混淆。例如：</p>
<p>👍</p>
<pre><code>wire [7:0] sum = a + b;  // Continuous assignment
</code></pre>
<p>👎</p>
<pre><code>logic [7:0] sum = a + b; // Initialization (not synthesizable)
</code></pre>
<p><code>sum</code>被初始化为 a 和 b 的初始值之和。</p>
<p>👍</p>
<pre><code>logic [7:0] acc = '0;    // Initialization (synthesizable on some FPGA tools)
</code></pre>
<p><code>logic</code>不合适的地方也有例外。例如，连接到双向 ( <code>inout</code>) 端口的网络必须用 声明<code>wire</code>。应该用简短的评论来证明这些例外是合理的。</p>
<p>DV（设计验证）允许使用 2 态逻辑，但 4 态和 2 态信号之间的所有接口必须<code>X</code>在解析为 2 态变量之前断言对 4 态网络的检查。</p>
<h3 id="逻辑与按位"><a href="#逻辑与按位" class="headerlink" title="逻辑与按位"></a>逻辑与按位</h3><p><em><strong>首选逻辑结构进行逻辑比较，按位进行数据。</strong></em></p>
<p>逻辑运算符 ( <code>!</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>==</code>, <code>!=</code>) 应用于评估逻辑（真或假）值的所有构造，例如 if 子句和三元赋值。对所有数据结构都优先使用按位运算符 ( <code>~</code>, <code>|</code>, <code>&amp;</code>, <code>^</code>)，即使是标量。在很明显要在逻辑上下文中使用评估表达式的情况下可以例外。</p>
<p>👍</p>
<pre><code>always_ff @(posedge clk_i or negedge rst_ni) begin
  if (!rst_ni) begin
    reg_q &lt;= '0;
  end else begin
    reg_q &lt;= reg_d;
  end
end

always_comb begin
  if (bool_a || (bool_b &amp;&amp; !bool_c) begin
    x = 1'b1;
  end else begin
    x = 1'b0;
end

assign z = ((bool_a != bool_b) || bool_c) ? a : b;
assign y = (a &amp; ~b) | c;
</code></pre>
<p>👎</p>
<pre><code>always_ff @(posedge clk_i or negedge rst_ni) begin
  if (~rst_ni) begin
    reg_q &lt;= '0;
  end else begin
    reg_q &lt;= reg_d;
  end
end

always_comb begin
  if (bool_a | (bool_b &amp; ~bool_c) begin
    x = 1'b1;
  end else begin
    x = 1'b0;
end

assign z = ((bool_a ^ bool_b) | bool_c) ? a : b;
assign y = (a &amp;&amp; !b) || c;
</code></pre>
<p>👍</p>
<pre><code>// allowed logical assignment for boolean test
assign request_valid = !fifo_empty &amp;&amp; data_available;

always_comb begin
  if (request_valid) begin
    output_valid = 1'b1;
  end else begin
    output_valid = 1'b0;
  end
end
</code></pre>
<h3 id="打包订购"><a href="#打包订购" class="headerlink" title="打包订购"></a>打包订购</h3><p><em><strong>位向量和压缩数组必须是 little-endian。</strong></em></p>
<p>声明位向量和压缩数组时，最高有效界限（冒号左侧）的索引必须大于或等于最低有效界限（冒号右侧）。</p>
<p>这种位向量声明风格保持压缩变量 little-endian。</p>
<p>例如：</p>
<pre><code>typedef logic [7:0] u8_t;
logic [31:0] u32_word;
u8_t [1:0] u16_word;
u8_t byte3, byte2, byte1, byte0;
assign u16_word = {byte1, byte0};
assign u32_word = {byte3, byte2, u16_word};
</code></pre>
<h3 id="无包装订购"><a href="#无包装订购" class="headerlink" title="无包装订购"></a>无包装订购</h3><p><em><strong>解压的数组必须是大端的。</strong></em></p>
<p>以大端方式声明解包数组（例如，<code>[n:m]</code>where <code>n &lt;= m</code>）。永远不要以 little-endian 顺序声明未打包的数组，例如 <code>[size-1:0]</code>.</p>
<p>使用较短的符号声明从零开始的解包数组<code>[size]</code>。据了解，<code>[size]</code>相当于大端声明 <code>[0:size-1]</code>。</p>
<pre><code>logic [15:0] word_array[3] = '{word0, word1, word2};
</code></pre>
<h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p><em><strong>状态机使用枚举来定义状态，并通过两个进程块实现：组合块和时钟块。</strong></em></p>
<p>每个状态机描述都包含三个部分：</p>
<ol>
<li>声明和描述状态的枚举。</li>
<li>一个组合过程块，它对状态进行解码以产生下一个状态和其他组合输出。</li>
<li>从下一个状态更新状态的时钟进程块。</li>
</ol>
<p><em>枚举状态</em></p>
<p>状态机的枚举语句应该列出状态机中的每个状态。描述状态的注释应推迟到下面组合过程块中的 case 语句。</p>
<p><code>UpperCamelCase</code>与其他 <a target="_blank" rel="noopener" href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#enumerations">枚举常量</a>一样，应以 in 命名状态。</p>
<p>除非有特殊情况，状态机的初始空闲状态将被命名为<code>Idle</code>or <code>StIdle</code>。（如果可以提高清晰度，则可以使用替代名称。）</p>
<p>理想情况下，每个模块应该只包含一个状态机。如果您的模块需要多个状态机，则需要为每个状态机的状态添加唯一的前缀（或后缀），以区分哪个状态与哪个状态机相关联。例如，具有“读取器”机器和“写入器”机器的模块可能具有<code>StRdIdle</code>状态和<code>StWrIdle</code>状态。</p>
<p><em>国家组合解码</em></p>
<p>组合过程块应包含：</p>
<ul>
<li>解码状态以产生下一个状态和组合输出的 case 语句。为清楚起见，仅应编码输出值偏离默认值的情况。</li>
<li>在 case 语句之前应该是一段代码，为每个组合输出定义默认值，包括“下一个状态”。</li>
<li>“下一个状态”变量的默认值应该是当前状态。然后，在状态之间转换时，解码状态的 case 语句将只分配给“下一个状态”。</li>
<li>在 case 语句中，每个状态选择之前都应该有一个注释，描述该状态在状态机中的功能。</li>
</ul>
<p><em>国家登记册</em></p>
<p>在此过程中不应执行除复位之外的任何逻辑。状态变量应该锁存“下一个状态”变量的值。</p>
<p><em>其他指南</em></p>
<p>如果可能，请尝试在名称开头附近选择不同的状态名称，以使它们在查看波形轨迹时更具可读性。</p>
<p><em>例子</em></p>
<p>👍</p>
<pre><code>// Define the states
typedef enum {
  StIdle, StFrameStart, StDynInstrRead, StBandCorr, StAccStoreWrite, StBandEnd
} alcor_state_e;

alcor_state_e alcor_state_d, alcor_state_q;

// Combinational decode of the state
always_comb begin
  alcor_state_d = alcor_state_q;
  foo = 1'b0;
  bar = 1'b0;
  bum = 1'b0;
  unique case (alcor_state_q)
    // StIdle: waiting for frame_start
    StIdle:
      if (frame_start) begin
        foo = 1'b1;
        alcor_state_d = StFrameStart;
      end
    // StFrameStart: Reset accumulators
    StFrameStart: begin
      // ... etc ...
    end
    // may be empty or used to catch parasitic states
    default: alcor_state_d = StIdle;
  endcase
end

// Register the state
always_ff @(posedge clk or negedge rst_n) begin
  if (!rst_n) begin
    alcor_state_q &lt;= StIdle;
  end else begin
    alcor_state_q &lt;= alcor_state_d;
  end
end
</code></pre>
<h3 id="低电平有效信号"><a href="#低电平有效信号" class="headerlink" title="低电平有效信号"></a>低电平有效信号</h3><p><em><strong><code>_n</code>后缀表示低电平有效信号。</strong></em></p>
<p>如果使用低电平有效信号，它们<code>_n</code>的名称中必须有后缀。否则，所有信号都假定为高电平有效。</p>
<h3 id="差分对"><a href="#差分对" class="headerlink" title="差分对"></a>差分对</h3><p><em><strong>使用<code>_p</code>和<code>_n</code>后缀表示差分对。</strong></em></p>
<p>例如，<code>in_p</code>包括<code>in_n</code>一个差分对组。</p>
<h3 id="延误"><a href="#延误" class="headerlink" title="延误"></a>延误</h3><p><em><strong>延迟一个时钟周期的信号应以<code>_q</code>后缀结尾。</strong></em></p>
<p>如果一个信号只是另一个信号的延迟版本，<code>_q</code>则应使用后缀来表示这种关系。</p>
<p>如果另一个信号随后被另一个时钟周期延迟，则应使用<code>_q2</code>后缀标识下一个信号<code>_q3</code>，以此类推。</p>
<p>例子：</p>
<pre><code>always_ff @(posedge clk) begin
  data_valid_q &lt;= data_valid_d;
  data_valid_q2 &lt;= data_valid_q;
  data_valid_q3 &lt;= data_valid_q2;
end
</code></pre>
<h3 id="包的通配符导入"><a href="#包的通配符导入" class="headerlink" title="包的通配符导入"></a>包的通配符导入</h3><p>通配符导入语法，例如<code>import ip_pkg::*;</code>，仅在包与使用该包的模块属于同一 IP 的情况下才允许使用。通配符导入语句必须放在模块头或模块体中。</p>
<p>👍</p>
<pre><code>// mod_a_pkg.sv and mod_a.sv are in the same IP.
// Packages can be imported in the module declaration if access to
// unqualified types is needed in the port list.

// mod_a_pkg.sv
package mod_a_pkg;

  typedef struct packed {
    ...
  } a_req_t;
endpackage

// mod_a.sv
module mod_a
  import mod_a_pkg::*;
(
  ...
  a_req_t a_req,
  ...
);

endmodule
</code></pre>
<p>👍</p>
<pre><code>// mod_a
module mod_a ();

  // mod_a_pkg.sv and mod_a.sv are in the same IP.
  import mod_a_pkg::*;

  ...

  a_req_t a_req;

endmodule
</code></pre>
<p>除上述情况外，不允许通配符导入。例如，下面的示例可能会<code>mod_a</code> 在源列表中的模块中创建名称冲突。</p>
<p>👎</p>
<pre><code>// mod_a.sv
import mod_a_pkg::*; // not allowed: imported to $root scope.

module mod_a ();

endmodule
</code></pre>
<p>其他不好的例子：</p>
<p>👎</p>
<pre><code>// wildcard import for other packages outside of the IP
module mod_a import mod_b_pkg::*; ();
</code></pre>
<p>👎</p>
<pre><code>module mod_a ();

  // not allowed: wildcard import of a package from a different IP
  import mod_b_pkg::*;

endmodule
</code></pre>
<h3 id="断言宏"><a href="#断言宏" class="headerlink" title="断言宏"></a>断言宏</h3><p>鼓励在整个设计中使用 SystemVerilog 断言 (SVA) 来检查功能正确性并标记无效条件。为了提高生产力并保持断言简洁明了，可以使用以下断言宏：</p>
<pre><code>// immediate assertion, to be placed within a process.
`ASSERT_I(&lt;name&gt;, &lt;property&gt;)
// immediate assertion wrapped within an initial block. can be used for things
// like parameter checking.
`ASSERT_INIT(&lt;name&gt;, &lt;property&gt;)
// concurrent assertion to be used for functional assertions.
`ASSERT(&lt;name&gt;, &lt;property&gt;, &lt;clk&gt;, &lt;reset condition&gt;)
// concurrent assertion that checks that a signal has a known value after reset
// (i.e. that the signal is not `X`).
`ASSERT_KNOWN(&lt;name&gt;, &lt;signal&gt;, &lt;clk&gt;, &lt;reset condition&gt;)
</code></pre>
<p>这些宏的实现（包括其他有用的变体）可以在这里找到： <a target="_blank" rel="noopener" href="https://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv">https ://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv</a></p>
<h4 id="关于安全关键应用程序的说明"><a href="#关于安全关键应用程序的说明" class="headerlink" title="关于安全关键应用程序的说明"></a>关于安全关键应用程序的说明</h4><p>对于安全关键应用程序，涉及保护 case 语句和三元组的断言宏的名称应以<code>_SEC</code>. 这可以在设计过程的后期阶段对这些语句进行特定于安全性的后处理。就功能而言，这些宏应该与原始断言相同，即</p>
<pre><code>`define ASSERT_SEC `ASSERT
`define ASSERT_I_SEC `ASSERT_I
`define ASSERT_KNOWN_SEC `ASSERT_KNOWN
</code></pre>
<p>很快，将在单独的文档中提供更多安全断言和编码风格指南。</p>
<h2 id="附录-精简风格指南"><a href="#附录-精简风格指南" class="headerlink" title="附录 - 精简风格指南"></a>附录 - 精简风格指南</h2><p>这是可移植样式指南的简短摘要。有关解释示例和例外情况，请参阅正文。</p>
<h3 id="基本样式元素"><a href="#基本样式元素" class="headerlink" title="基本样式元素"></a>基本样式元素</h3><ul>
<li>使用 SystemVerilog-2012 约定，文件命名为 module.sv，每个模块一个文件</li>
<li>只有 ASCII，每行<strong>100 个字符，****没有</strong>制表符，所有配对关键字的每个缩进<strong>两个空格。</strong></li>
<li>C++ 风格注释<code>//</code></li>
<li>对于一行中的多个项目，<strong>一个</strong>空格必须分隔逗号和下一个字符</li>
<li>在关键字和二元运算符周围包含<strong>空格</strong></li>
<li>案例项目和冒号、函数/任务/宏调用和左括号之间<strong>没有空格</strong></li>
<li>换行应该缩进<strong>四个</strong>空格</li>
<li><code>begin</code>必须与前面的关键字在同一行并结束行</li>
<li><code>end</code>必须开始一个新行</li>
</ul>
<h3 id="构造命名"><a href="#构造命名" class="headerlink" title="构造命名"></a>构造命名</h3><ul>
<li>对实例名称、信号、声明、变量、类型使用<strong>lower_snake_case</strong></li>
<li>对可调参数、枚举值名称使用<strong>UpperCamelCase</strong></li>
<li>将<strong>ALL_CAPS</strong>用于常量并定义宏</li>
<li>主时钟信号命名为<code>clk</code>。所有时钟信号必须以<code>clk_</code></li>
<li>复位信号为<strong>低电平有效</strong>和<strong>异步</strong>，默认名称为 <code>rst_n</code></li>
<li>信号名称应具有描述性并在整个层次结构中保持一致</li>
</ul>
<h3 id="信号和类型的后缀"><a href="#信号和类型的后缀" class="headerlink" title="信号和类型的后缀"></a>信号和类型的后缀</h3><ul>
<li>添加<code>_i</code>到模块输入、<code>_o</code>模块输出或<code>_io</code>双向模块信号</li>
<li>注册信号的输入（下一个状态）应该有<code>_d</code>，输出<code>_q</code>作为后缀</li>
<li>信号的流水线版本应命名为<code>_q2</code>,<code>_q3</code>等以反映它们的延迟</li>
<li>低电平有效信号应使用<code>_n</code>。当使用差分信号 <code>_p</code>用于高电平有效</li>
<li>枚举类型应以<code>_e</code></li>
<li>多个后缀不会用 . 分隔<code>_</code>。<code>n</code>应该先出现 <code>i</code>，<code>o</code>或<code>io</code>最后出现</li>
</ul>
<h3 id="语言特点-1"><a href="#语言特点-1" class="headerlink" title="语言特点"></a>语言特点</h3><ul>
<li>对模块使用<strong>完整的端口声明样式</strong>，首先声明的任何时钟和复位</li>
<li>使用<strong>命名参数</strong>进行实例化，所有声明的端口必须存在，没有<code>.*</code></li>
<li>顶级参数优于<code> </code>define`全局参数</li>
<li>使用<strong>符号命名的常量</strong>而不是原始数字</li>
<li>应<code>localparam</code>在单独的 <strong>.svh</strong>文件中声明局部常量和全局常量。</li>
<li><code>logic</code>优于<code>reg</code>and <code>wire</code>，明确声明所有信号</li>
<li><code>always_comb</code>,<code>always_ff</code>并且<code>always_latch</code>优先于<code>always</code></li>
<li>不鼓励使用接口</li>
<li>顺序逻辑必须使用<strong>非阻塞</strong>赋值</li>
<li>组合块必须使用<strong>块</strong>分配</li>
<li>不鼓励使用锁存器，尽可能使用触发器</li>
<li><code>X</code>强烈建议不要在 RTL 中使用分配，而是使用 SVA 来检查无效行为。</li>
<li><code>assign</code>在可行的情况下首选语句。</li>
<li>使用<code>unique case</code>并始终定义一个<code>default</code>案例</li>
<li>在使用有符号算术的地方使用可用的有符号算术结构</li>
<li>打印时使用<code>0b</code>和<code>0x</code>作为二进制和十六进制的前缀。用于 <code>_</code>清晰</li>
<li>使用逻辑结构 (ie <code>||</code>) 进行逻辑比较，按位 (ie <code>|</code>) 进行数据比较</li>
<li>位向量和压缩数组必须是 little-endian，unpacked 数组必须是 big-endian</li>
<li>FSM：状态寄存器的过程中除了复位之外不应该执行<strong>任何逻辑</strong></li>
<li>一个组合流程应该首先定义流程中所有输出的<strong>默认值</strong></li>
<li>下一个状态变量的默认值应该是当前状态</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">故里的梦</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://wutaoizp.github.io/2022/10/27/lowrisc-verilog-bian-ma-feng-ge-zhi-nan/">https://wutaoizp.github.io/2022/10/27/lowrisc-verilog-bian-ma-feng-ge-zhi-nan/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">故里的梦</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: null,
        id: '2022-10-27T20-32-21',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/11/01/ucie-specification-revision-1.0/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="UCIe(Universal Chiplet Interconnect Express) spec 1.0(第一章)">
                        
                        <span class="card-title">UCIe(Universal Chiplet Interconnect Express) spec 1.0(第一章)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-11-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            故里的梦
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/10/27/ru-he-xie-testbench/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="TestBench文件编写">
                        
                        <span class="card-title">TestBench文件编写</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-10-27
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            故里的梦
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="8463251865"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022</span>
            
            <span id="year">2022</span>
            <a href="/about" target="_blank">故里的梦</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2207982844@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2207982844" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2207982844" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
