<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>上传git-&gt;gitee</title>
      <link href="/2022/11/01/shang-chuan-git-gitee/"/>
      <url>/2022/11/01/shang-chuan-git-gitee/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在上传的文件夹路径下右键鼠标打开gitbash"><a href="#1-在上传的文件夹路径下右键鼠标打开gitbash" class="headerlink" title="1.在上传的文件夹路径下右键鼠标打开gitbash"></a>1.在上传的文件夹路径下右键鼠标打开gitbash</h2><h2 id="2-初始话git"><a href="#2-初始话git" class="headerlink" title="2.初始话git"></a>2.初始话git</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> init</code></pre><h2 id="3-添加需要上传的文件到git暂存区"><a href="#3-添加需要上传的文件到git暂存区" class="headerlink" title="3.添加需要上传的文件到git暂存区"></a>3.添加需要上传的文件到git暂存区</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> add <span class="token keyword">.</span> <span class="token comment" spellcheck="true">#将当前目录所有文件添加到git暂存区</span>$ <span class="token function">git</span> add 文件名 <span class="token comment" spellcheck="true">#将当前目录某文件添加到git暂存区</span></code></pre><h2 id="3-设置提交信息"><a href="#3-设置提交信息" class="headerlink" title="3.设置提交信息"></a>3.设置提交信息</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"my commit"</span> <span class="token comment" spellcheck="true">#提交并备注提交信息</span></code></pre><p><code>例如：git commit -m "IMC完成测试"</code></p><h2 id="4-链接到远程仓库"><a href="#4-链接到远程仓库" class="headerlink" title="4.链接到远程仓库"></a>4.链接到远程仓库</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> remote add origin 仓库地址</code></pre><h2 id="5-推送到远程仓库"><a href="#5-推送到远程仓库" class="headerlink" title="5.推送到远程仓库"></a>5.推送到远程仓库</h2><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> push -u origin master <span class="token comment" spellcheck="true">#普通推送</span></code></pre><p>尽量不要使用强制推送，否则会覆盖别人的推送记录</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> push -u origin master -f <span class="token comment" spellcheck="true">#强制推送</span></code></pre><h2 id="6-可能出现的问题"><a href="#6-可能出现的问题" class="headerlink" title="6.可能出现的问题"></a>6.可能出现的问题</h2><p><img src="https://s1.ax1x.com/2022/11/01/x74efS.png"></p><p>更改 <code>http.postBuffer </code>的大小，将其设置为 <code>524288000</code></p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config http.postBuffer 524288000</code></pre><p>然后再推送</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UCIe(Universal Chiplet Interconnect Express) spec 1.0(第一章)</title>
      <link href="/2022/11/01/ucie-specification-revision-1.0/"/>
      <url>/2022/11/01/ucie-specification-revision-1.0/</url>
      
        <content type="html"><![CDATA[<h1 id="UCIe-Universal-Chiplet-Interconnect-Express-spec-1-0"><a href="#UCIe-Universal-Chiplet-Interconnect-Express-spec-1-0" class="headerlink" title="UCIe(Universal Chiplet Interconnect Express) spec 1.0"></a><font color="green" size="72">UCIe(Universal Chiplet Interconnect Express) spec 1.0</font></h1><h1 id="第一章"><a href="#第一章" class="headerlink" title="(第一章)"></a>(第一章)</h1><h2 id="1-0-Introduction"><a href="#1-0-Introduction" class="headerlink" title="1.0 Introduction"></a>1.0 Introduction</h2><p>此章节提供UCIe架构的一个概览。UCIe是一个开放，多协议支持，包交换的同封装上多die互联的标准，用于在同一个封装上连接多个die。此标准的意在打造一个充满活力的生态系统，支持可可使用UCIe互联的多die结构。UCIe在公共物理层与链路层上支持多种协议（PCIe 、CXL和可用于映射任何所选择协议的原始模式，只要两端都支持）。它包含构建SoC所需要的元素，比如应用层，以及与封装相关的物理因素（bump位置，功耗传输，散热方案）。该协议规范的定义是为了确保具有不同性能特征的各种设备之间的互操作性。提供了明确定义的调试和合规机制以确保互操作性。预计此协议规范将会以向后兼容的方式发展。</p><p>尽管UCIe支持广泛的使用模型，但是一些模型是为了说明其可以在计算行业中能够引领的功能创新。最初始能够映射到UCIe的协议是PCIe与CXL。所有协议的映射工作是通过Flit格式实现的，包括原始模式也是。PCIe和CXL在业界都被广泛使用，在UCIe中通过UCIe Adapter和PHY替换原有的PCIe SerDes PHY和PCIe/CXL 逻辑PHY以及链路级别重传功能来实现更多的封装集成方式，以提高功耗和性能特性。UCIe还支持与协议无关的原始模式，以支持映射其他的协议；同时允许在封装上额外集成独立的SerDes收发模块。</p><p><strong>图1</strong>展示了一个SoC的封装，其中包含了通过UCIe连接的CPU Die，其他用途的加速器 Die和I/O Die。加速器Die或I/O Die能够通过运行在UCIe上的CXL与CPU Die相连接，能够实现CXL的I/O、一致性与内存协议（<a href="https://link.zhihu.com/?target=http://CXL.io">http://CXL.io</a>、CXL.cache、CXL.mem）。I/O块能够提供面向外部的CXL引脚、PCIe引脚与DDR引脚。加速器Die也可以使用运行在UCIe的PCIe事务连接到CPU。封装上的CPU Die与CPU Die也可以通过UCIe进行互联，实现一致性协议。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7TrKe.png"></p><center>图1 通过UCIe连接的由CPU Die，加速器Die，和I/O Die组成的封装</center><p>UCIe Retimer能够用于把UCIe的连接拓展到封装之外的其他封装互联。封装之外的互联方式包括电缆或光缆或其他任何的用于机架级别的连接方式，如图2所示。UCIe协议规范要求UCIe Retimer部署在UCIe的本地封装接口上并且保证在两个封装之间的Die与Die交互的Flit是依照UCIe协议并且使用相应的通道拓展技术。（The UCIe specification requires the UCIe Retimer to implement the UCIe interface to the die that it connects on its local package and ensure that the Flits are delivered across the two dies across the packages following UCIe protocol using the channel extension technology of its choice.）</p><p><strong>图2</strong>给出了使用CXL 2.0或更高版本协议的机架级别互联的示意图。<strong>图2a</strong>展示了一个机架级别的示意图，其中来自不同计算机刀片服务器的多个计算节点连接到交换机，同时该交换机连接到多个CXL加速器/type-3内存设备，同时上述的所有设备都能够防止在一个或多个抽屉式的机箱中。这种连接的逻辑关系如<strong>图2b</strong>所示，其中每一个host（H1、H2、…)都是上述的抽屉式机箱。每一个抽屉式机箱都通过UCIe Retimer使用封装外的CXL协议互联与交换机进行连接，如<strong>图2c</strong>所示。交换机同时具有封装在一起的Retimer，Retimer通过UCIe与同一封装下的交换机进行连接，Retimer的另一侧是通过PCIe/CXL的物理接口连接到其他封装的加速器/内存设备，如图2c所示。</p><p><img src="https://s1.ax1x.com/2022/11/01/x77dds.png"></p><center>图2 UCIe 能够在机架层面提供远距离的连接<center><p>此版本的UCIe协议不涉及3D封装。它允许两种不同的封装形式：标准封装（2D）和高级封装（2.5D）。这样就涵盖了从成本优先的选项到性能优先的选项。</p><ul><li>标准封装：这种封装方式常用于低成本与在有机封装基板上实现长距离通信（10mm-25mm）的场景，但与封装外的SerDes通信方式相比能够提供更加好的误码率特性。图3展示了一个使用标准封装的例子。<strong>表4</strong>展示了使用标准封装的UCIe协议的传输特性。</li></ul><p><img src="https://s1.ax1x.com/2022/11/01/x7TcVA.png"></p><center>图3 标准封装接口 <center><p><img src="https://s1.ax1x.com/2022/11/01/x7T25t.png"></p><center>表4 UCIe标准封装下的特性<ul><li>高级封装：此封装提供了一种聚焦于高性能的应用场景。因此为了得到更高的带宽与更低的时延与更优秀的能耗比，牺牲了传输距离（小于2mm）。<strong>图4图5图6</strong>展示了使用高级封装的例子。<strong>表5</strong>展示了使用高级封装的UCIe协议的传输特性。</li></ul><p><img src="https://s1.ax1x.com/2022/11/01/x7TWPP.png"></p><center>图4&amp;图5&amp;图6 三种不同的高级封装接口<p><img src="https://s1.ax1x.com/2022/11/01/x7TgUI.png"></p><center>表5 高级封装接口的特性<h3 id="1-1-UCIe-Components"><a href="#1-1-UCIe-Components" class="headerlink" title="1.1 UCIe Components"></a>1.1 UCIe Components</h3><p>UCIe是一个分层实现的协议，每一层都有其特定的功能实现。<strong>图7</strong>展示了UCIe协议栈的三个主要部分以及各层之间的功能划分。UCIe协议栈中的每一个部分都需要支持其所宣告的功能与数据带宽。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7T4xS.png"></p><center>UCIe的功能层级<h4 id="1-1-1-Protocol-Layer"><a href="#1-1-1-Protocol-Layer" class="headerlink" title="1.1.1 Protocol Layer"></a>1.1.1 Protocol Layer</h4><p>虽然协议层与特定的应用程序有着强相关，UCIe协议规范提供了通过UCIe链路传输CXL或PCIe协议的例子。UCIe支持以下协议以启用不同的应用场景：</p><ul><li>PCIe协议规范中定义的PCIe 6.0 Flit 模式。</li><li>CXL协议规范中定义的CXL 2.0和更高版本的协议。</li><li>Streaming协议：此模式为使用UCIe传输的用户自定义的协议提供了通用的传输模式。</li></ul><p>对于上述的每一个协议，通过UCIe传输时可以使用不同的优化与相关的Flit传输方式。第2章与第3章将会对不同协议的细节与Flit格式。</p><h4 id="1-1-2-Die-To-Die-Adapter"><a href="#1-1-2-Die-To-Die-Adapter" class="headerlink" title="1.1.2 Die-To-Die Adapter"></a>1.1.2 Die-To-Die Adapter</h4><p>D2D Adapter在UCIe链路中负责协调协议层与物理层之间成功地进行数据传输功能。它尽可能地减少主要数据路径上的逻辑，为协议Flit提供低延迟，高度优化的数据路径。在传输CXL协议时，多个协议module同时实现所需要的ARB/MUX功能也是由D2D Adapter提供的。对于原始误码率小于1e-27的场景，Adapter能够实现CRC校验码检测与重传功能以保证误码率指标。重传的规则请查阅第3.7节。</p><p>D2D Adapter负责与远程链路伙伴协调更高级别的链路状态机与bring up、协议选项相关参数交换，以及与远程链路伙伴进行电源管理。第3章讲述了D2D Adapter相关内容。</p><h4 id="1-1-3-Physical-Layer"><a href="#1-1-3-Physical-Layer" class="headerlink" title="1.1.3 Physical Layer"></a>1.1.3 Physical Layer</h4><p>物理层的子部分如<strong>图8</strong>所示。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7Th28.png"></p><center>图8 物理层组件<p>UCIe在物理bump上的主要数据路径按组别划分，每一组中有多个lane，每一组被称为Module。一个Module是UCIe中AFE的最小粒度单位。标准封装和高级封装中每个模块的lane数量在第4章中讲述。一个给定的协议层或D2D Adapter能够通过多个Module进行数据传输。</p><p>UCIe的物理链路由两个部分组成：</p><ul><li>Sideband（边带）：</li></ul><p>此连接用于参数交换，寄存器访问与和远程链路伙伴进行协调设置和管理。其每个传输方向都由对应的时钟信号引脚与数据信号引脚组成。无论主带数据路径的传输速度如何，边带时钟信号都固定在800Mhz。UCIe物理层的边带逻辑必须使用备用电源和处于”always on”的电源域中。每个module都拥有属于自己的边带信号引脚。</p><p>对于高级封装，每个方向上的边带信号引脚都有对应冗余引脚以用于故障修复。</p><ul><li>Mainband（主带）：</li></ul><p>此连接组成了UCIe的主要数据路径。其中每个module由一个时钟信号，一个数据有效信号和N个数据lane组成。</p><p>对于采用高级封装的场景，上述数据lane的数量N为64，同时有额外的4个用于故障修复的冗余数据lane。</p><p>对于采用标准封装的场景，上述数据lane的数量N为16，但并没有额外用于故障修复的冗余数据lane。</p><p>逻辑物理层通过不同的功能和相关执行顺序建立起适当的链路管理功能与数据传输功能。（例如边带传输，主带训练或主带修复）。第4章与第5章讲述了物理层操作的相关细节。</p><h4 id="1-1-4-Interfaces"><a href="#1-1-4-Interfaces" class="headerlink" title="1.1.4 Interfaces"></a>1.1.4 Interfaces</h4><p>UCIe定义物理层与D2D Adapter之间的接口为RDI（Raw D2D Interface），定义D2D Adapter与协议层之间的接口为FDI（Flit-aware D2D Interface），详细请参详第8章。</p><p>执行如此定义的原因如下：</p><ul><li>允许供应商与SoC制造商能够以较低的成本和更快的上市时间以混合和匹配来自不同供应商的不同层级。例如，让协议层与D2D Adapter和来自其他不同供应商的且符合本协议规范中定义的接口的物理层一起工作。</li><li>考虑到硅后验证的巨大开销与成本，对于此协议规范中所定义的接口拥有一致的BFM理解和开发能够使得支持UCIe的IP开发更简单。</li></ul><h3 id="1-2-UCIe-Configurations"><a href="#1-2-UCIe-Configurations" class="headerlink" title="1.2 UCIe Configurations"></a>1.2 UCIe Configurations</h3><p>此部分讲述UCIe中不同的配置与排列。</p><h4 id="1-2-1-Single-Module-Configuration"><a href="#1-2-1-Single-Module-Configuration" class="headerlink" title="1.2.1 Single Module Configuration"></a>1.2.1 Single Module Configuration</h4><p>使用标准封装的单module实现方式提供16个数据lane，如<strong>图9</strong>所示。使用高级封装的单module实现方式提供64个数据lane，如<strong>图10</strong>所示。如果同时例化多个单module，每一个module需要独立运行，比如运行在不同的传输频率下。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7TorQ.png"></p><center>图9 高级封装下的单模块配置<p><img src="https://s1.ax1x.com/2022/11/01/x7TIKg.png"></p><center>图10 标准封装下的单模块配置<h4 id="1-2-2-Multi-Module-Configuration"><a href="#1-2-2-Multi-Module-Configuration" class="headerlink" title="1.2.2 Multi Module Configuration"></a>1.2.2 Multi Module Configuration</h4><p>此协议允许2个或4个module的配置方式。处于multi-module下的子module不能单独运行。<strong>图11</strong>和<strong>图12</strong>分别展示了2个和4个module配置的实例。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7TTbj.png"></p><p><img src="https://s1.ax1x.com/2022/11/01/x7THVs.png"></p><center>图11&amp;图12标准封装下的多模块配置<h3 id="1-3-UCIe-Retimers"><a href="#1-3-UCIe-Retimers" class="headerlink" title="1.3 UCIe Retimers"></a>1.3 UCIe Retimers</h3><p>如前面所描述，UCIe Retimer用于支持不同类型的封装互联，以拓展处于不同封装中的两个UCIe Die之间进行互联。每一个UCIe Retimer拥有一个本地UCIe链路以连接本地UCIe Die，同时拥有一个外部的UCIe链路以连接其他片外的封装片。<strong>图13</strong>展示了一个利用UCIe Retimer进行不同封装片外的UCIe Die 0与UCIe Die1之间互联的例子。UCIe Retimer 0和UCIe Die 0通过UCIe 链路0在封装0上相连接。UCIe Retimer 1和UCIe Die 1通过UCIe 链路0在封装1上相连接。术语“remote Retimer partner”（远程Retimer伙伴）用于指代连接到封装外的互联远端的UCIe Retimer Die。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7Tban.png"></p><center>图13 UCIe Retimer的模块层级连接图<p>UCIe Retimer的职责包括如下：</p><p>提供可靠的跨封装Flit传输，以下三种选项用于实现此职责：</p><ul><li>Retimer能够使用当前所进行传输的协议（如PCIe或CXL）底层定义的FEC与CRC进行传输保障，前提是使用的封装外连接能够正确识别当前协议栈下传输中可能出现的错误模型。此时UCIe链路将会被设置为使用原始模式来传输其所使用的协议的bit流。在这种情况下，需要在UCIe Die上调整队列大小以满足底层数据往返延迟。</li><li>Retimer允许提供必要的FEC，CRC和重传功能以满足片外互联的误码率要求。在这样的情况下，Flit将会通过三个独立的链路传输。每一个UCIe Retimer对其同一封装下的UCIe Die执行独立的Ack/Nak握手并且与远程Retimer伙伴也执行独立的Ack/Nak握手。</li><li>Retimer通过使用自定义的FEC替代原有PCIe或CXL定义的FEC，或者在已有PCIe或CXL定义的FEC的基础上增加自定义的FEC，但使用当前底层协议实现的CRC和重传机制。在这种情况下，需要在UCIe Die上调整队列大小以满足底层数据往返延迟。</li><li>与远程Retimer伙伴解决链路和协议的参数以保证UCIe Die端到端之间的互操作性。例如，允许Retimer在图13中的封装0与封装1上强制使用相同的链路宽度、速度、协议（包括任何相关的协议特定参数）和Flit格式。具体的解析机制包括不同封装之间的参数交换引发的信息传输的实现方式需要依据具体Retimer情况而言，并且需要保证所使用的信息交互方式能够被两边的封装都能支持。然而，为了确保UCIe链路的鲁棒性，以避免由于通过片外互联与远程Retimer伙伴进行参数交互通信时引致的长时间等待而触发不必要的超时，UCIe 协议规范定义了“Stall”的响应方式以等待可能出现延迟的边带信息。Retimer需要依照UCIe规范中定义的规则响应”Stall”以避免在与远程Retimer伙伴进行协商或等待其响应时出现不必要的超时。Retimer有责任确保UCIe链路不会无限期停止。</li><li>与远程Retimer伙伴协同对Adapter链路状态与RDI状态进行解析以确保端到端操作符合规范。参考第3章以获得更多信息。</li></ul><p>对于流控与反压机制：</p><ul><li>从UCIe Die发送到UCIe Retimer的数据流控机制通过Credits实现。这些Credit是基于已有的底层协议的Credit机制（比如PCIe中的PRH与PRD credit）。这些UCIe D2D credit需要被用于跨越两个UCIe Retimer的流控并且传输到UCIe Retimer的任何数据最终必须要由远程UCIe Die所使用，而不是被其他设备使用。每一个UCIe Retimer需要为从其同一封装内的UCIe Die接收到的Flit实现一个接收缓冲区（Receive Buffer）。接收缓冲器的credit需要在初始参数交换时宣布到UCIe Die上，并且UCIe Die在收到接收缓冲器的credit前不能够往Retimer发送任何的数据。一个credit对应着256字节的数据（包括所有的FEC、CRC）。在每次传输完成之后将会根据valid信号重载credit数量（参照第4.1.2节）。当RDI状态从Active跳出时，credit计数器将会回退到初始宣布的数值。UCIe Retimer需要在RDI重新进入Active状态前清空或转移其接收缓冲器中的数据。</li><li>在D2D Adapter层中从UCIe Retimer传输到UCIe Die将不会受到流控的限制。如果需要实现流控，UCIe Retimer可以与另一个UCIe Retimer建立独立地流控机制，这内容超过了本协议规范的范围。</li></ul><h3 id="1-4-UCIe-Key-Performance-Targets"><a href="#1-4-UCIe-Key-Performance-Targets" class="headerlink" title="1.4 UCIe Key Performance Targets"></a>1.4 UCIe Key Performance Targets</h3><p>表6给出了UCIe的性能目标。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7TOP0.png"></p><center>表6 UCIe的关键性能指标<ol><li>Die Edge Bandwidth Density（第5章中定义）为45um（高级封装）和110um（标准封装）的bump pitch。</li><li>Energy Efficiency包含所有物理层相关的电路：发送，接收，锁相环，时钟分配等。通道长短带来不同的能耗将会在第5章中讨论。</li><li>Latency包含Adapter上的延时与物理层发送与接收的延时。参照第5章以得到更多关于物理层时延的内容。</li></ol><h3 id="1-5-Interoperability"><a href="#1-5-Interoperability" class="headerlink" title="1.5 Interoperability"></a>1.5 Interoperability</h3><p>封装设计者需要确保连接在封装上的Die能够互相操作。这包括采用兼容性的封装互联（标准封装或高级封装）、协议、电压等级等。强烈建议Die的发送电压小于0.85V；这样他们就可以在可预见的未来与更多的工艺节点继续宁互联操作。</p><p>此协议规范涵盖了针对高级封装的各种bump pitch范围的互操作性。预计随着时间的推移，使用的bump pitch将会越来越小。通过更小的bump pitch，设计能够降低传输频率以优化面积，并且在减少面积的情况解决高带宽传输的功率传输与热限制。<strong>表7</strong>中总结了4组对应的bump pitch。</p><p>依据第5章中讲述的PHY定义，保证了每个组内以及跨组的互操作性。<strong>表6</strong>中提供的性能指标采用45um的bump pitch，这是基于此协议发布时广泛采用的技术。</p><p><img src="https://s1.ax1x.com/2022/11/01/x7Tq5q.png"></p><center>表7 不同凹凸间距的组合</center></center></center></center></center></center></center></center></center></center></center></center></center></center></center>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lowRISC Verilog 编码风格指南</title>
      <link href="/2022/10/27/lowrisc-verilog-bian-ma-feng-ge-zhi-nan/"/>
      <url>/2022/10/27/lowrisc-verilog-bian-ma-feng-ge-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h1 id="lowRISC-Verilog-编码风格指南"><a href="#lowRISC-Verilog-编码风格指南" class="headerlink" title="lowRISC Verilog 编码风格指南"></a>lowRISC Verilog 编码风格指南</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h3><p>Verilog 是低RISC 可移植IP 的主要逻辑设计语言。</p><p>Verilog 和 SystemVerilog（在本文档中通常简称为“Verilog”）可以以截然不同的风格编写，这可能导致代码冲突和代码审查延迟。本样式指南旨在提高 Verilog 跨组的可读性。引用 <a href="https://google.github.io/styleguide/cppguide.html">Google C++ 风格指南</a>：“创建通用的、必需的习语和模式使代码更容易理解。”</p><p>本指南定义了 Verilog 的可移植样式。目标是：</p><ul><li>促进硬件开发项目的一致性</li><li>推广最佳实践</li><li>增加代码共享和重用</li></ul><p>本样式指南定义了 Verilog-2001 和 SystemVerilog 兼容代码的样式。此外，本样式指南定义了可综合代码和测试台代码的样式。</p><p>有关此样式指南的简明表格表示，请参见<a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#appendix---condensed-style-guide">附录。</a></p><p><strong>目录</strong></p><ul><li>lowRISC Verilog 编码风格指南<ul><li>基本<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#summary">概括</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#terminology-conventions">术语约定</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#default-to-c-like-formatting">默认为类 C 格式</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#style-guide-exceptions">样式指南例外</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#which-verilog-to-use">使用哪个 Verilog</a></li></ul></li><li>Verilog/SystemVerilog 约定<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#summary-1">概括</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#file-extensions">文件扩展名</a></li><li>一般文件外观<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#characters">人物</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#posix-file-endings">POSIX 文件结尾</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#line-length">线长</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#no-tabs">没有标签</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#no-trailing-spaces">没有尾随空格</a></li></ul></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#begin--end">开始/结束</a></li><li>缩进<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#indented-sections">缩进部分</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#line-wrapping">换行</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#preprocessor-directives">预处理器指令</a></li></ul></li><li>间距<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#comma-delimited-lists">逗号分隔的列表</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#tabular-alignment">表格对齐</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#expressions">表达式</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#array-dimensions-in-declarations">声明中的数组维度</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#parameterized-types">参数化类型</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#labels">标签</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#case-items">案例项目</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#function-and-task-calls">函数和任务调用</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#macro-calls">宏调用</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#line-continuation">续行</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#space-around-keywords">关键字周围的空间</a></li></ul></li><li>括号<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#ternary-expressions">三元表达式</a></li></ul></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#comments">注释</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#declarations">声明</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#basic-template">基本模板</a></li></ul></li><li>我们<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#summary-2">概括</a></li><li>常数<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#parameterized-objects-modules-etc">参数化对象（模块等）</a></li></ul></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#macro-definitions">宏定义</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#suffixes">后缀</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#enumerations">枚举</a></li><li>信号命名<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#use-descriptive-names">使用描述性名称</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#prefixes">前缀</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#hierarchical-consistency">层次一致性</a></li></ul></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#clocks">时钟</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#resets">重置</a></li></ul></li><li>语言特点<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#preferred-systemverilog-constructs">首选 SystemVerilog 构造</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#package-dependencies">包依赖</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#module-declaration">模块声明</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#module-instantiation">模块实例化</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants-1">常数</a></li><li>信号宽度<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#always-be-explicit-about-the-widths-of-number-literals">始终明确数字文字的宽度。</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#port-connections-on-module-instances-must-always-match-widths-correctly">模块实例上的端口连接必须始终正确匹配宽度。</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#do-not-use-multi-bit-signals-in-a-boolean-context">不要在布尔上下文中使用多位信号。</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#bit-slicing">位切片</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#handling-width-overflow">处理宽度溢出</a></li></ul></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#blocking-and-non-blocking-assignments">阻塞和非阻塞赋值</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#delay-modeling">延迟建模</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#sequential-logic-latches">顺序逻辑（锁存器）</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#sequential-logic-registers">顺序逻辑（寄存器）</a></li><li>不在乎（<code>X</code>‘s）<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#catching-errors-where-invalid-values-are-consumed">捕获使用无效值的错误</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#specific-guidance-on-case-statements-and-ternaries">案例陈述和三元组的具体指导</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#dynamic-array-indexing">动态数组索引</a></li></ul></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#combinational-logic">组合逻辑</a></li><li>案例陈述<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#wildcards-in-case-items">案例项目中的通配符</a></li></ul></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#generate-constructs">生成构造</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#signed-arithmetic">有符号算术</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#number-formatting">数字格式</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#functions-and-tasks">功能和任务</a></li><li>有问题的语言特征和结构<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#floating-begin-end-blocks">浮动起始块</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#hierarchical-references">分层引用</a></li></ul></li></ul></li><li>设计惯例<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#summary-3">概括</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#declare-all-signals">声明所有信号</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#use-logic-for-synthesis">用于<code>logic</code>合成</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#logical-vs-bitwise">逻辑与按位</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#packed-ordering">打包订购</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#unpacked-ordering">无包装订购</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#finite-state-machines">有限状态机</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#active-low-signals">低电平有效信号</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#differential-pairs">差分对</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#delays">延误</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#wildcard-import-of-packages">包的通配符导入</a></li><li>断言宏<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#a-note-on-security-critical-applications">关于安全关键应用程序的说明</a></li></ul></li></ul></li><li>附录 - 精简风格指南<ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#basic-style-elements">基本样式元素</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#construct-naming">构造命名</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#suffixes-for-signals-and-types">信号和类型的后缀</a></li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#language-features-1">语言特点</a></li></ul></li></ul></li></ul><h3 id="术语约定"><a href="#术语约定" class="headerlink" title="术语约定"></a>术语约定</h3><p>除非另有说明，否则以下术语约定适用于本样式指南：</p><ul><li><em><strong>“必须</strong></em>”一词表示强制性要求。同样，<em><strong>不</strong></em>表示禁止。命令式和声明式语句对应于<em><strong>must</strong></em>。</li><li><em><strong>推荐</strong></em>这个词表示某种行动方案是首选或最合适的。类似地，<em><strong>不推荐</strong></em>表示一个行动过程不合适，但不被禁止。使用其他选项可能有理由，但必须充分理解这样做的含义和原因。</li><li><em><strong>“可能</strong></em>”一词表示允许和可选的操作过程。</li><li><em><strong>“可以</strong></em>”这个词表示在物质、物理或因果限制的情况下可能采取的行动。</li></ul><h3 id="默认为类-C-格式"><a href="#默认为类-C-格式" class="headerlink" title="默认为类 C 格式"></a>默认为类 C 格式</h3><p><em><strong>在适当的情况下，格式代码与 <a href="https://google.github.io/styleguide/cppguide.html">https://google.github.io/styleguide/cppguide.html一致</a></strong></em></p><p>Verilog 是一种类 C 语言，在适当的情况下，我们默认与 <a href="https://google.github.io/styleguide/cppguide.html">Google 的 C++ 样式指南</a>保持一致。</p><p>特别是，我们继承了这些特定的格式指南：</p><ul><li>一般来说，<a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#naming">名称</a>应该是描述性的，避免缩写。</li><li>禁止使用非 ASCII 字符。</li><li>缩进使用空格，没有制表符。缩进是两个空格用于嵌套，四个空格用于续行。</li><li><code>if</code>在 <a href="https://google.github.io/styleguide/cppguide.html#Conditionals">条件表达式</a>中的括号和括号之间放置一个空格。</li><li>在运算符周围使用水平空格，并避免在行尾出现尾随空格。</li><li>保持一致和良好的 <a href="https://google.github.io/styleguide/cppguide.html#Punctuation,_Spelling_and_Grammar">标点、拼写和语法</a> （在评论中）。</li><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#comments">对注释</a>使用标准格式，包括<a href="https://google.github.io/styleguide/cppguide.html#TODO_Comments">TODO</a>和<a href="https://google.github.io/styleguide/cppguide.html#Deprecation_Comments">deprecation</a>的类 C 格式。</li></ul><h3 id="样式指南例外"><a href="#样式指南例外" class="headerlink" title="样式指南例外"></a>样式指南例外</h3><p><em><strong>用评论证明所有例外。</strong></em></p><p>没有风格指南是完美的。有时，实现工作设计或解决工具问题的最佳途径是简单地切断 Gordian Knot 并创建与本样式指南不一致的代码。必要时偏离风格指南总是可以的，只要简短的评论清楚地证明了这种必要性，以及适当的 lint waiver pragma。</p><h3 id="使用哪个-Verilog"><a href="#使用哪个-Verilog" class="headerlink" title="使用哪个 Verilog"></a>使用哪个 Verilog</h3><p><em><strong>首选 SystemVerilog-2017。</strong></em></p><p>所有 RTL 和测试都应在 SystemVerilog 中开发，遵循 <a href="https://ieeexplore.ieee.org/document/8299595">IEEE 1800-2017 (SystemVerilog-2017) 标准，</a><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#problematic-language-features-and-constructs">禁止的功能</a>除外。</p><p><a href="https://ieeexplore.ieee.org/browse/standards/get-program/page/series?id=80">标准文档可通过IEEE GET</a>免费获得（需要注册）。</p><h2 id="Verilog-SystemVerilog-约定"><a href="#Verilog-SystemVerilog-约定" class="headerlink" title="Verilog/SystemVerilog 约定"></a>Verilog/SystemVerilog 约定</h2><h3 id="概括-1"><a href="#概括-1" class="headerlink" title="概括"></a>概括</h3><p>本节主要讨论风格的美学方面：行长、缩进、间距等。</p><h3 id="文件扩展名"><a href="#文件扩展名" class="headerlink" title="文件扩展名"></a>文件扩展名</h3><p><em><strong>使用<code>.sv</code>SystemVerilog 文件的扩展名（或<code>.svh</code>通过预处理器包含的文件）。</strong></em></p><p>文件扩展名具有以下含义：</p><ul><li><code>.sv</code>表示定义模块或包的 SystemVerilog 文件。</li><li><code>.svh</code>表示一个 SystemVerilog 头文件，旨在使用预处理器``include`指令包含在另一个文件中。</li><li><code>.v</code>表示定义模块或包的 Verilog-2001 文件。</li><li><code>.vh</code>表示 Verilog-2001 头文件。</li></ul><p>只有<code>.sv</code>和<code>.v</code>文件旨在作为编译单元。<code>.svh</code>并且<code>.vh</code> 文件只能被``include`编辑到其他文件中。</p><p>除网表文件外，每个 .sv 或 .v 文件应仅包含一个模块，并且名称应相关联。例如，文件<code>foo.sv</code>应该只包含模块<code>foo</code>。</p><h3 id="一般文件外观"><a href="#一般文件外观" class="headerlink" title="一般文件外观"></a>一般文件外观</h3><h4 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h4><p><em><strong>仅使用带有 UNIX 风格行尾 ( <code>"\n"</code>) 的 ASCII 字符。</strong></em></p><h4 id="POSIX-文件结尾"><a href="#POSIX-文件结尾" class="headerlink" title="POSIX 文件结尾"></a>POSIX 文件结尾</h4><p><em><strong>非空文件上的所有行都必须以换行符 ( <code>"\n"</code>) 结尾。</strong></em></p><h4 id="线长"><a href="#线长" class="headerlink" title="线长"></a>线长</h4><p><em><strong>以每行 100 个字符包装代码。</strong></em></p><p>符合样式的 Verilog 代码的最大行长度为每行 100 个字符。</p><p>例外：</p><ul><li>任何不可能换行的地方（例如，包含路径可能超过 100 个字符）。</li></ul><p><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#line-wrapping">换行</a>包含有关如何换行长行的附加指南。</p><h4 id="没有标签"><a href="#没有标签" class="headerlink" title="没有标签"></a>没有标签</h4><p><em><strong>不要在任何地方使用标签。</strong></em></p><p>使用空格缩进或对齐文本。有关缩进和换行的规则，请参阅<a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#indentation">缩进。</a></p><p>要将任何文件上的制表符转换为空格，您可以使用 <a href="http://linux.die.net/man/1/expand">UNIX<code>expand</code></a>实用程序。</p><h4 id="没有尾随空格"><a href="#没有尾随空格" class="headerlink" title="没有尾随空格"></a>没有尾随空格</h4><p><em><strong>删除行尾的尾随空格。</strong></em></p><h3 id="开始-结束"><a href="#开始-结束" class="headerlink" title="开始/结束"></a>开始/结束</h3><p><em><strong>使用<code>begin</code>and<code>end</code>除非整个语句适合一行。</strong></em></p><p>如果语句在块边界处换行，则必须使用<code>begin</code>and<code>end.</code>仅当整个以分号结尾的语句适合单行时才可以<code>begin</code>省略 <code>end</code>。</p><p>👍</p><pre><code>// Wrapped procedural block requires begin and end.always_ff @(posedge clk) begin  q &lt;= d;end</code></pre><p>👍</p><pre><code>// The exception case, where begin and end may be omitted as the entire// structure fits on a single line.always_ff @(posedge clk) q &lt;= d;</code></pre><p>👎</p><pre><code>// Incorrect because a wrapped statement must have begin and end.always_ff @(posedge clk)  q &lt;= d;</code></pre><p><code>begin</code>必须与前面的关键字在同一行，并结束该行。 <code>end</code>必须开始一个新行。<code>end else begin</code>必须在一条线上。唯一的例外是如果<code>end</code>有标签，则后续<code>else</code>应该在新行上。</p><p>👍</p><pre><code>// "end else begin" are on the same line.if (condition) begin  foo = bar;end else begin  foo = bum;end</code></pre><p>👍</p><pre><code>// begin/end are omitted because each semicolon-terminated statement fits on// a single line.if (condition) foo = bar;else foo = bum;</code></pre><p>👎</p><pre><code>// Incorrect because "else" must be on the same line as "end".if (condition) begin  foo = bar;endelse begin  foo = bum;end</code></pre><p>👍</p><pre><code>// An exception is made for labeled blocks.if (condition) begin : a  foo = bar;end : aelse begin : b  foo = bum;end : b</code></pre><p>上述风格也适用于案例陈述中的个别案例项目。 如果整个 case 项（case 表达式和相关的语句）适合一行，则可以省略<code>begin</code>。<code>end</code>否则，<code>begin</code> 在与 case 表达式相同的行上使用关键字。</p><p>👍</p><pre><code>// Consistent use of begin and end for each case item is good.unique case (state_q)  StIdle: begin    state_d = StA;  end  StA: begin    state_d = StB;  end  StB: begin    state_d = StIdle;    foo = bar;  end  default: begin    state_d = StIdle;  endendcase</code></pre><p>👍</p><pre><code>// Case items that fit on a single line may omit begin and end.unique case (state_q)  StIdle: state_d = StA;  StA: state_d = StB;  StB: begin    state_d = StIdle;    foo = bar;  end  default: state_d = StIdle;endcase</code></pre><p>👎</p><pre><code>unique case (state_q)  StIdle:           // These lines are incorrect because we should not wrap    state_d = StA;  // case items at a block boundary without using begin  StA:              // and end.  Case items should fit on a single line, or    state_d = StB;  // else the procedural block must have begin and end.  StB: begin    foo = bar;    state_d = StIdle;  end  default: begin    state_d = StIdle;  endendcase</code></pre><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p><em><strong>缩进是每层两个空格。</strong></em></p><p>使用空格进行缩进。不要使用标签。您应该将编辑器设置为在您按 Tab 键时发出空格。</p><h4 id="缩进部分"><a href="#缩进部分" class="headerlink" title="缩进部分"></a>缩进部分</h4><p>始终为所有配对关键字的封闭部分添加额外的缩进级别。SystemVerilog 关键字对示例：<code>begin / end</code>, <code>module / endmodule</code>, <code>package / endpackage</code>, <code>class / endclass</code>, <code>function / endfunction</code>.</p><h4 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h4><p>包装长表达式时，将表达式的连续部分缩进四个空格，如下所示：</p><p>👍</p><pre><code>assign zulu = enabled &amp;&amp; (    alpha &lt; bravo &amp;&amp;    charlie &lt; delta);assign addr = addr_gen_function_with_many_params(    thing, other_thing, long_parameter_name, x, y,    extra_param1, extra_param2);assign structure = '{    src: src,    dest: dest,    default: '0};</code></pre><p>或者，如果它提高了可读性，则将表达式的后续部分与分组左括号或大括号对齐，如下所示：</p><p>👍</p><pre><code>assign zulu = enabled &amp;&amp; (alpha &lt; bravo &amp;&amp;                          charlie &lt; delta);assign addr = addr_gen_function(thing, other_thing,                                long_parameter_name,                                x, y);assign structure = '{src: src,                     dest: dest,                     default: '0};</code></pre><p>包装表达式中的运算符可以放在每行的末尾或开头，但这必须在文件中一致地完成。</p><p>多行表达式的一行结束的开放语法字符（例如<code>{</code>或）应在各自的行上以关闭字符 ( , ) 终止。例子：<code>(``}``)</code></p><p>👍</p><pre><code>assign bus_concatenation = {    bus_valid,    bus_parity[7:0],    bus_valid[63:0]};inst_type inst_name1 (  .clk_i       (clk),  .data_valid_i(data_valid),  .data_value_i(data_value),  .data_ready_o(data_ready));</code></pre><h4 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h4><p><em><strong>保持分支预处理器指令左对齐且不缩进。</strong></em></p><p>保持分支预处理器指令（<code> </code>ifdef<code>, ``ifndef</code>, <code>else`, </code>elsif<code>, ``endif</code>）左对齐，即使它们是嵌套的。缩进文本的条件分支，就好像没有预处理器指令一样。非分支预处理器指令必须遵循与常规代码相同的缩进规则。</p><p>👍</p><pre><code>package foo;`ifdef FOO              // good: branching directive left-aligned  `include "foo.sv";    // normal indentation for non-branching directives  parameter bit A = 1;  // normal indentation for the regular code`ifdef BAR              // good: branching directive left-aligned  parameter bit A = 2;`else  parameter bit A = 3;`endif`endifendpackage : foo</code></pre><p>未缩进的分支预处理器指令会破坏阅读流程以强调存在条件文本。保留条件分支文本不缩进将导致预处理后的文本看起来正确缩进。</p><h3 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h3><h4 id="逗号分隔的列表"><a href="#逗号分隔的列表" class="headerlink" title="逗号分隔的列表"></a>逗号分隔的列表</h4><p><em><strong>对于一行中的多个项目，一个空格必须分隔逗号和下一个字符。</strong></em></p><p>为了便于阅读，允许使用额外的空格。</p><p>👍</p><pre><code>bus = {addr, parity, data};a = myfunc(lorem, ipsum, dolor, sit, amet, consectetur, adipiscing, elit,           rhoncus);mymodule mymodule(.a(a), .b(b));</code></pre><p>👎</p><pre><code>{parity,data} = bus;a = myfunc(a,b,c);mymodule mymodule(.a(a),.b(b));</code></pre><h4 id="表格对齐"><a href="#表格对齐" class="headerlink" title="表格对齐"></a>表格对齐</h4><p>表格对齐方式将两条或多条相似的线组合在一起，使相同的部分直接位于彼此之上。这种对齐方式可以很容易地看出哪些字符是相同的，哪些字符是不同的。</p><p><em><strong>通常鼓励使用表格对齐。</strong></em></p><p><em><strong>如本指南的相应小节所述，某些结构需要使用表格对齐。</strong></em></p><p>需要表格对齐的结构：</p><ul><li><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#module-instantiation">模块实例化中的端口表达式</a></li></ul><p>每个由空行分隔的代码块都被视为单独的“表格”。</p><p>使用空格，而不是制表符。</p><p>例如：</p><p>👍</p><pre><code>logic [7:0]  my_interface_data;logic [15:0] my_interface_address;logic        my_interface_enable;logic       another_signal;logic [7:0] something_else;</code></pre><p>👍</p><pre><code>mod u_mod (  .clk_i,  .rst_ni,  .sig_i          (my_signal_in),  .sig2_i         (my_signal_out),  // comment with no blank line maintains the block  .in_same_block_i(my_signal_in),  .sig3_i         (something),  .in_another_block_i(my_signal_in),  .sig4_i            (something));</code></pre><h4 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h4><p><em><strong>在所有二元运算符的两边都包含空格。</strong></em></p><p>在二元运算符周围使用空格。添加足够的空格以提高可读性。</p><p>例如：</p><p>👍</p><pre><code>assign a = ((addr &amp; mask) == My_addr) ? b[1] : ~b[0];  // good</code></pre><p>好于</p><p>👎</p><pre><code>assign a=((addr&amp;mask)==My_addr)?b[1]:~b[0];  // bad</code></pre><p><strong>例外：</strong>声明位向量时，可以使用紧凑表示法。例如：</p><p>👍</p><pre><code>wire [WIDTH-1:0] foo;   // this is acceptablewire [WIDTH - 1 : 0] foo;  // fine also, but not necessary</code></pre><p>将替换表达式拆分为多行时，请使用与等效的 if-then-else 行类似的格式。例如：</p><p>👍</p><pre><code>assign a = ((addr &amp; mask) == `MY_ADDRESS) ?           matches_value :           doesnt_match_value;</code></pre><h4 id="声明中的数组维度"><a href="#声明中的数组维度" class="headerlink" title="声明中的数组维度"></a>声明中的数组维度</h4><p>在压缩尺寸周围添加一个空格。</p><p>不要添加空格：</p><ul><li>在标识符和未包装尺寸之间。</li><li>多个维度之间。</li></ul><p>适用于打包和解包数组以及动态数组、关联数组和队列。</p><p>👍</p><pre><code>logic [7:0][3:0] data[128][2];typedef logic [31:0] word_t;bit bit_array[512];data_t some_array[];data_t some_map[addr_t];data_t some_q[$];</code></pre><p>👎</p><pre><code>// There must not be a space between dimensions.logic [7:0] [3:0] data[128] [2];// There must be a space around packed dimensions.typedef logic[31:0]word_t;// There must not be a space between identifier and unpacked dimension.bit bit_array [512];// Dynamic, associative, and queue "dimensions" are treated the same as unpacked// dimensions.  There must not be a space.data_t some_array [];data_t some_map [addr_t];data_t some_q [$];</code></pre><h4 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h4><p><em><strong>在类型参数之前添加一个空格，除非类型是限定名称的一部分。</strong></em></p><p>限定名称包含至少一个<code>::</code>连接其段的范围运算符。限定名称中的空格会破坏对一个符号的引用的连续性，因此不得添加。参数列表必须遵循 <a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#comma-delimited-lists">逗号后空格</a>规则。</p><p>👍</p><pre><code>my_fifo #(.WIDTH(4), .DEPTH(2)) my_fifo_nibble ...class foo extends bar #(32, 8);  // unqualified base class  ...endclassfoo_h = my_class#(.X(1), .Y(0))::type_id::create("foo_h");  // static method callmy_pkg::x_class#(8, 1) bar;  // package-qualified name</code></pre><p>👎</p><pre><code>my_fifo#(.WIDTH(4), .DEPTH(2)) my_fifo_2by4 ...class foo extends bar#(32, 8);  // unqualified base class  ...endclassfoo_h = my_class #(.X(1), .Y(0))::type_id::create("foo_h");  // static method callmy_pkg::x_class #(8, 1) bar;  // package-qualified name</code></pre><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><p><em><strong>标记代码块时，冒号前后各加一个空格。</strong></em></p><p>例如：</p><p>👍</p><pre><code>begin : fooend : foo</code></pre><p>👎</p><pre><code>end:bar            // There must be a space before and after the colon.endmodule: foobar  // There must be a space before the colon.</code></pre><h4 id="案例项目"><a href="#案例项目" class="headerlink" title="案例项目"></a>案例项目</h4><p>案例项目的冒号之前不能有空格；案例项目的冒号后必须至少有一个空格。</p><p>案例项目<code>default</code>必须包含冒号。</p><p>例如：</p><p>👍</p><pre><code>unique case (my_state)  StInit:   $display("Shall we begin");  StError:  $display("Oh boy this is Bad");  default: begin    my_state = StInit;    interrupt = 1;  endendcase</code></pre><p>👎</p><pre><code>unique case (1'b1)  (my_state == StError)  : interrupt = 1; // Excess whitespace before colon  default:begin end                       // Missing space after colonendcase</code></pre><h4 id="函数和任务调用"><a href="#函数和任务调用" class="headerlink" title="函数和任务调用"></a>函数和任务调用</h4><p><em><strong>函数和任务调用在函数名称或任务名称与左括号之间不得有任何空格。</strong></em></p><p>例如：</p><p>👍</p><pre><code>process_packet(pkt);</code></pre><p>👎</p><pre><code>process_packet (pkt);  // There must not be a space before "("</code></pre><h4 id="宏调用"><a href="#宏调用" class="headerlink" title="宏调用"></a>宏调用</h4><p><em><strong>宏调用在宏名称和左括号之间不能有任何空格。</strong></em></p><p>例如：</p><p>👍</p><pre><code>`uvm_error(ID, "you fail")`ASSERT(name, a &amp; b, clk, rst)</code></pre><p>👎</p><pre><code>`uvm_error (ID, "you fail")  // There must not be a space before "("`ASSERT (name, a &amp; b, clk, rst)</code></pre><h4 id="续行"><a href="#续行" class="headerlink" title="续行"></a>续行</h4><p><em><strong>必须右对齐续行。</strong></em></p><p>对齐续行符（’ <code>\ </code>‘ 字符）有助于在视觉上标记多行宏的结尾。对齐位置只需要超出多行宏的最右边至少一个空格，当空格不分割标记时，但不应超过最大行长度。</p><pre><code>`define REALLY_LONG_MACRO(arg1, arg2, arg3) \    do_something(arg1);                     \    do_something_else(arg2);                \    final_action(arg3);</code></pre><h4 id="关键字周围的空间"><a href="#关键字周围的空间" class="headerlink" title="关键字周围的空间"></a>关键字周围的空间</h4><p><em><strong>在 SystemVerilog 关键字前后包含空格。</strong></em></p><p>不要包含空格：</p><ul><li>在紧跟在组开头之后的关键字之前，例如左括号。</li><li>在行首的关键字之前。</li><li>在行尾的关键字之后。</li></ul><p>例如：</p><pre><code>// Normal indentation before if.  Include a space after if.if (foo) beginend// Include a space after always, but not before posedge.always_ff @(posedge clk) beginend</code></pre><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p><em><strong>使用括号使操作明确。</strong></em></p><p>在任何情况下，如果一个理性的人需要思考或参考运算符优先级图表，请使用括号代替以使操作顺序明确。</p><h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><p><em><strong>嵌套在另一个三元表达式的真实条件中的三元表达式必须用括号括起来。</strong></em></p><p>例如：</p><p>👍</p><pre><code>assign foo = condition_a ? (condition_a_x ? x : y) : b;</code></pre><p>虽然以下嵌套三元组对编译器只有一种含义，但其含义可能不清楚并且对人类来说很容易出错：</p><p>👎</p><pre><code>assign foo = condition_a ? condition_a_x ? x : y : b;</code></pre><p><em><strong>如果代码格式传达相同的信息，例如在描述优先级复用器时，可以省略括号。</strong></em></p><p>👍</p><pre><code>assign foo = condition_a ? a :             condition_b ? b : not_a_nor_b;</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><em><strong><code>// foo</code>首选C++ 样式注释 ( )。<code>/\* bar \*/</code>也可以使用C 风格的注释 ( )。</strong></em></p><p>单独一行的注释描述了后面的代码。对代码行的注释描述了该行代码。</p><p>例如：</p><pre><code>// This comment describes the following module.module foo;  ...endmodule : foolocalparam bit ValBaz = 1;  // This comment describes the item to the left.</code></pre><p>有时使用标题样式的注释来构造代码以分隔模块内的不同功能部分（如 FSM、主数据路径或寄存器）可能很有用。在这种情况下，首选样式是单行部分名称，并带有<code>//</code>C++ 样式注释，如下所示：</p><pre><code>module foo;  ////////////////  // Controller //  ////////////////  ...  ///////////////////////  // Main ALU Datapath //  ///////////////////////  ...endmodule : foo</code></pre><p>如果设计者想使用注释来标记特定部分的开始/结束以获得更好的可读性（例如，在嵌套的 for 循环块中），首选的方法是使用没有额外轮廓符的单行注释，如下面的例子。</p><p>👍</p><pre><code>// begin: iterate over foobarfor (...) begin...end// end: iterate over foobar</code></pre><p>👍</p><pre><code>for (...) begin // iterate over foobar...end // iterate over foobar</code></pre><p>👎</p><pre><code>//-------------------------- iterate over foobar -------------------------------for (...) begin...end//-------------------------- iterate over foobar -------------------------------</code></pre><p>👎</p><pre><code>///////////////////////////////// begin iterate over foobar /////////////////////////////////for (...) begin...end///////////////////////////////// end iterate over foobar   /////////////////////////////////</code></pre><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p><em><strong>信号必须在使用前声明。这意味着不得使用隐式网络声明。</strong></em></p><p>在模块中，<strong>建议</strong>在接近首次使用时声明信号、类型、枚举和本地参数。这使读者更容易找到声明并查看信号类型。</p><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><p><em><strong>下面给出了演示许多项目的模板。</strong></em></p><p>模板：</p><pre><code>// Copyright lowRISC contributors.// Licensed under the Apache License, Version 2.0, see LICENSE for details.// SPDX-License-Identifier: Apache-2.0//// One line description of the modulemodule my_module #(  parameter Width = 80,  parameter Height = 24) (  input              clk_i,  input              rst_ni,  input              req_valid_i,  input  [Width-1:0] req_data_i,  output             req_ready_o,  ...);  logic [Width-1:0] req_data_masked;  submodule u_submodule (    .clk_i,    .rst_ni,    .req_valid_i,    .req_data_i (req_data_masked),    .req_ready_o(req_ready),    ...  );  always_comb begin    req_data_masked = req_data_i;    case (fsm_state_q)      ST_IDLE: begin        req_data_masked = req_data_i &amp; MASK_IDLE;        ...  end  ...endmodule</code></pre><h2 id="我们"><a href="#我们" class="headerlink" title="我们"></a>我们</h2><h3 id="概括-2"><a href="#概括-2" class="headerlink" title="概括"></a>概括</h3><table><thead><tr><th>构造</th><th>风格</th></tr></thead><tbody><tr><td>声明（模块、类、包、接口）</td><td><code>lower_snake_case</code></td></tr><tr><td>实例名称</td><td><code>lower_snake_case</code></td></tr><tr><td>信号（网络和端口）</td><td><code>lower_snake_case</code></td></tr><tr><td>变量、函数、任务</td><td><code>lower_snake_case</code></td></tr><tr><td>命名代码块</td><td><code>lower_snake_case</code></td></tr><tr><td>`定义宏</td><td><code>ALL_CAPS</code></td></tr><tr><td>参数化模块、类和接口的可调参数</td><td><code>UpperCamelCase</code></td></tr><tr><td>常数</td><td><code>ALL_CAPS</code>或者<code>UpperCamelCase</code></td></tr><tr><td>枚举类型</td><td><code>lower_snake_case_e</code></td></tr><tr><td>其他 typedef 类型</td><td><code>lower_snake_case_t</code></td></tr><tr><td>枚举值名称</td><td><code>UpperCamelCase</code></td></tr></tbody></table><h3 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h3><p><em><strong>使用项目包文件中的参数声明全局常量。</strong></em></p><p>在这种情况下，<strong>常量</strong>不同于参数化模块、类等对象的可调参数。</p><p>显式声明常量的类型。</p><p>声明常量时：</p><ul><li>在一个包内使用<code>parameter</code>。</li><li>在模块或类中使用<code>localparam</code>.</li></ul><p>定义常量的首选方法是声明 a<code>package</code>并将所有常量声明<code>parameter</code>为该包中的 a。如果常量仅在一个文件中使用，则可以将它们定义在该文件中而不是单独的包中。</p><p>在项目的主包中定义项目范围的常量。</p><p>其他包也可以用自己的<code>parameter</code>常量声明，以方便创建可以在许多项目中重复使用的 IP。</p><p>所有不可变常量的首选命名约定是使用<code>ALL_CAPS</code>，但有时使用<code>UpperCamelCase</code>可能被认为更自然。</p><table><thead><tr><th>常量类型</th><th>风格偏好</th><th>对话</th></tr></thead><tbody><tr><td>`定义</td><td><code>ALL_CAPS</code></td><td>真正恒定</td></tr><tr><td>模块参数</td><td><code>UpperCamelCase</code></td><td>真正可以通过实例化修改，而不是恒定的</td></tr><tr><td>派生的本地参数</td><td><code>UpperCamelCase</code></td><td>虽然没有直接修改，但仍然跟踪模块参数</td></tr><tr><td>可调局部参数</td><td><code>UpperCamelCase</code></td><td>虽然预计不会在最终 RTL 版本中发生变化，但供设计师用来方便地探索设计空间</td></tr><tr><td>真正的 localparam 常数</td><td><code>ALL_CAPS</code></td><td>例子<code>localparam OP_JALR = 8'hA0;</code></td></tr><tr><td>枚举成员真常数</td><td><code>ALL_CAPS</code></td><td>例子<code>typedef enum ... { OP_JALR = 8'hA0;</code></td></tr><tr><td>枚举集成员</td><td><code>ALL_CAPS</code>或者<code>UpperCamelCase</code></td><td>例子<code>typedef enum ... { ST_IDLE, ST_FRAME_START, ST_DYN_INSTR_READ ...</code>，<code>typedef enum ... { StIdle, StFrameStart, StDynInstrRead...</code>。任意值的集合，可以是任何一种约定。</td></tr></tbody></table><p>常量的单位应该在符号名称中描述，除非常量是无单位的或单位是“位”。例如，<code>FooLengthBytes</code>。</p><p>例子：</p><p>👍</p><pre><code>// package-scopepackage my_pkg;  parameter int unsigned NUM_CPU_CORES = 64;  // reference elsewhere as my_pkg::NUM_CPU_CORESendpackage</code></pre><h4 id="参数化对象（模块等）"><a href="#参数化对象（模块等）" class="headerlink" title="参数化对象（模块等）"></a>参数化对象（模块等）</h4><p><em><strong>用于<code>parameter</code>参数化和<code>localparam</code>声明模块范围的常量。在包中，使用<code>parameter</code>.</strong></em></p><p>您可以创建参数化模块、类和接口以促进设计重用。</p><p><code>parameter</code>在参数化模块的<code>module</code>声明中使用关键字来指示用户在实例化时需要调整哪些参数。所有参数的首选命名约定是 <code>UpperCamelCase</code>. 一些项目可能会选择使用<code>ALL_CAPS</code>来区分可调参数和常量。</p><p>声明中的派生参数<code>module</code>应使用<code>localparam</code>. 一个例子如下所示。</p><pre><code>module modname #(  parameter  int Depth  = 2048,         // 8kB default  localparam int Aw     = $clog2(Depth) // derived parameter) (  ...);endmodule</code></pre><p>``define<code>并且</code>defparam`永远不应该用于参数化模块。</p><p>使用<a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants">包参数</a>通过层次结构而不是参数来传输全局常量。要声明一个范围在特定 SystemVerilog 模块内部的常量，<a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants">请</a><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants">改用<code>localparam</code></a>.</p><p>何时使用参数化模块的示例：</p><ul><li>当一个模块的多个实例将被实例化时，需要通过一个参数来区分。</li><li>作为将模块专门用于特定总线宽度的一种方式。</li><li>作为记录允许在模块内更改哪些全局参数的一种方式。</li></ul><p>显式声明参数的类型。</p><p>使用参数的类型来帮助限制合法范围。例如<code>int unsigned</code>对于一般的非负整数值，<code>bit</code>对于布尔值。对可调参数值的任何进一步限制必须用断言记录。</p><p>可调参数值应始终具有合理的默认值。</p><p>如需更多阅读内容，请参阅<a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-884-complex-digital-systems-spring-2005/related-resources/parameter_models.pdf">用于创建参数化模型的新 Verilog-2001 技术</a>。</p><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p><em><strong>宏应该是带下划线的 ALL_CAPITALS。</strong></em></p><p>宏应全部为大写字母并带有下划线。</p><p><strong>全局定义</strong>是项目中所有源文件共享的头文件中的刻度定义宏。为了减少命名空间冲突，全局定义应以一组相关宏的名称为前缀，后跟一对下划线：</p><pre><code>// The following two constants are in the FOO namespace of the// SN chip.`define SN_FOO__ALPHA_BETA  5`define SN_FOO__GAMMA_OMEGA 6</code></pre><p><strong>本地定义</strong>是一个刻度定义的宏，只能在单个本地文件的范围内使用。使用后必须明确未定义，以避免污染全局宏命名空间。为了表明宏仅用于本地范围，宏名称应以单个下划线作为前缀。</p><p>为确保本地定义保持本地，请注意不要<code> </code>include<code>在宏定义和</code> <code>undef</code>.</p><p>例子：</p><pre><code>`define _MAKE_THING(_x) \    thing i_thing_##_x (.clk(clk), .i(i##_x) .o(o##_x));`_MAKE_THING(a)`_MAKE_THING(b)`_MAKE_THING(c)`undef _MAKE_THING</code></pre><h3 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h3><p>后缀用于多个地方以指导意图。下表列出了具有特殊含义的后缀。</p><table><thead><tr><th>后缀</th><th>竞技场</th><th>意图</th></tr></thead><tbody><tr><td><code>_e</code></td><td>类型定义</td><td>枚举类型</td></tr><tr><td><code>_t</code></td><td>类型定义</td><td>其他类型定义，包括信号簇</td></tr><tr><td><code>_n</code></td><td>信号名称</td><td>低电平有效信号</td></tr><tr><td><code>_n</code>, <code>_p</code></td><td>信号名称</td><td>差分对，低电平有效和高电平有效</td></tr><tr><td><code>_d</code>,<code>_q</code></td><td>信号名称</td><td>寄存器的输入输出</td></tr><tr><td><code>_q2</code>, <code>_q3</code>, 等</td><td>信号名称</td><td>流水线版本的信号；<code>_q</code>是一个延迟周期，<code>_q2</code>是两个周期，<code>_q3</code>是三个，等等</td></tr><tr><td><code>_i</code>, <code>_o</code>, <code>_io</code></td><td>信号名称</td><td>模块输入、输出和双向</td></tr></tbody></table><p>当需要多个后缀时，请使用以下指南：</p><ul><li>指导后缀加在一起，不被附加<code>_</code> 字符分隔（<code>_ni</code>不<code>_n_i</code>）</li><li>如果信号为低电平有效<code>_n</code>将是第一个后缀</li><li>如果信号是模块输入/输出，字母将排在最后。</li><li><code>_d</code>传播和<code>_q</code>到模块边界不是强制性的。</li></ul><p>例子：</p><p>👍</p><pre><code>module simple (  input        clk_i,  input        rst_ni,              // Active low reset  // writer interface  input [15:0] data_i,  input        valid_i,  output       ready_o,  // bi-directional bus  inout [7:0]  driver_io,         // Bi directional signal  // Differential pair output  output       lvds_po,           // Positive part of the differential signal  output       lvds_no            // Negative part of the differential signal);  logic valid_d, valid_q, valid_q2, valid_q3;  assign valid_d = valid_i; // next state assignment  always_ff @(posedge clk or negedge rst_ni) begin    if (!rst_ni) begin      valid_q  &lt;= '0;      valid_q2 &lt;= '0;      valid_q3 &lt;= '0;    end else begin      valid_q  &lt;= valid_d;      valid_q2 &lt;= valid_q;      valid_q3 &lt;= valid_q2;    end  end  assign ready_o = valid_q3; // three clock cycles delayendmodule // simple</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><em><strong>名称枚举类型<code>snake_case_e</code>。命名枚举值<code>ALL_CAPS</code>或 <code>UpperCamelCase</code>.</strong></em></p><p>始终<code>enum</code>使用<code>typedef</code>. 必须指定任何枚举类型的存储类型。对于可综合枚举，存储类型必须是 4 状态数据类型（<code>logic</code>而不是<code>bit</code>）。</p><p><code>enum</code>不允许使用匿名类型，因为它们使在整个项目和跨项目的其他地方使用该类型变得更加困难。</p><p>枚举类型名称应仅包含小写字母数字字符和下划线。您必须在枚举类型名称后面加上<code>_e</code>.</p><p>枚举值名称（常量）通常应该是<code>ALL_CAPS</code>，例如， <code>READY_TO_SEND</code>以反映它们的常量性质，尤其是对于真正不可更改的值，例如定义的操作码分配。有时<code>UpperCamelCase</code> 可能是首选，当枚举类型的分配值实际上是设计者不关心的时候，就像状态机值一样。有关如何考虑此建议的讨论，请参阅关于 <a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#constants">常量的对话。</a></p><p>👍</p><pre><code>typedef enum logic [7:0] {  // 8-bit opcodes  OP_JALR = 8'hA0,  OP_ADDI = 8'h47,  OP_LDW  = 8'h0B} opcode_e;opcode_e op_val;</code></pre><p>👍</p><pre><code>typedef enum logic [1:0] {  // A 2-bit enumerated type  ACC_WRITE,  ACC_READ,  ACC_PAUSE} access_e; // new named type is createdaccess_e req_access, resp_access;</code></pre><p>👍</p><pre><code>typedef enum logic [1:0] {  // A 2-bit enumerated type  AccWrite,  AccRead,  AccPause} access_e; // new named type is createdaccess_e req_access, resp_access;</code></pre><p>👎</p><pre><code>enum {  // Typedef is missing, storage type is missing.  Write,  Read} req_access, resp_access; // anonymous enum type</code></pre><h3 id="信号命名"><a href="#信号命名" class="headerlink" title="信号命名"></a>信号命名</h3><p><em><strong><code>lower_snake_case</code>命名信号时使用。</strong></em></p><p>在这种情况下，<strong>信号</strong>意味着 SystemVerilog 设计中的网络、变量或端口。</p><p>信号名称可能包含小写字母数字字符和下划线。</p><p>信号名称不应以下划线后跟数字结尾（例如<code>foo_1</code>、<code>foo_2</code>等）。许多综合工具使用该命名约定将总线映射到网络，因此在检查综合网表时，类似命名的网络可能会导致混淆。</p><p>保留的<a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx13_1/ite_r_verilog_reserved_words.htm">Verilog</a>或 SystemVerilog 关键字永远不能用作名称。</p><p>与不同语言互操作时，请注意不要使用其他语言的关键字。</p><h4 id="使用描述性名称"><a href="#使用描述性名称" class="headerlink" title="使用描述性名称"></a>使用描述性名称</h4><p><em><strong>名称应描述信号的用途。</strong></em></p><p>使用整个单词。除非在最常见的地方，否则避免使用缩写词和缩写词。倾向于描述性的信号名称而不是简洁。</p><h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><p>使用通用前缀来标识一起操作的信号组。例如，AXI-S 接口的所有元素都将共享一个前缀：<code>foo_valid</code>、、 <code>foo_ready</code>和<code>foo_data</code>。</p><p>此外，对于具有多个时钟的任何模块，应使用前缀清楚地标记哪个信号在哪个时钟组中。有关详细信息，请参阅<a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#clocks">时钟域部分。</a></p><p>例子：</p><ul><li>与控制 blockram 相关的信号可能共享一个<code>bram_</code>前缀。</li><li>同步的信号<code>clk_dram</code>而不<code>clk</code>应该共享<code>dram_</code>前缀。</li></ul><p>代码示例：</p><p>👍</p><pre><code>module fifo_controller (  input         clk_i,  input         rst_ni,  // writer interface  input [15:0]  wr_data_i,  input         wr_valid_i,  output        wr_ready_o,  // reader interface  output [15:0] rd_data_o,  output        rd_valid_o,  output [7:0]  rd_fullness_o,  input         rd_ack_i,  // memory interface:  output [7:0]  mem_addr_o,  output [15:0] mem_wdata_o,  output        mem_we_o,  input  [15:0] mem_rdata_i);</code></pre><p>这种命名约定使得使用简单且一致的规则将端口名称映射到相似的信号名称变得更加容易。有关更多信息，请参阅<a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#hierarchical-consistency">分层一致性部分。</a></p><h4 id="层次一致性"><a href="#层次一致性" class="headerlink" title="层次一致性"></a>层次一致性</h4><p><em><strong>同一信号在层次结构的任何级别都应具有相同的名称。</strong></em></p><p>连接到实例端口的信号应与该端口具有相同的名称。通过以这种方式进行，直接连接的信号应该在任何层次结构级别保持相同的名称。</p><p>此约定的例外情况是预期的，例如：</p><ul><li>将端口连接到信号数组的元素时。</li><li>将通用端口名称映射到更特定于设计的名称时。例如，两个通用块，一个带有<code>host_bus</code>端口，一个带有 <code>device_bus</code>端口，可以通过<code>foo_bar_bus</code>信号连接。</li></ul><p>在每种例外情况下，应注意使端口名称到信号名称的映射尽可能明确和一致。</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p><em><strong>所有时钟信号必须以 开头<code>clk</code>。</strong></em></p><p>设计的主系统时钟必须命名为<code>clk</code>。可以使用 <code>clk</code>与模块中的大部分逻辑同步的默认时钟来表示。</p><p>如果一个模块包含多个时钟，则非系统时钟的时钟应使用唯一标识符命名，并以<code>clk_</code>前缀开头。例如：<code>clk_dram</code>、<code>clk_axi</code>等。请注意，此前缀将用于标识该时钟域中的其他信号。</p><h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><p><em><strong>复位是低电平有效和异步的。默认名称是<code>rst_n</code>.</strong></em></p><p>芯片范围内的所有复位都定义为低电平有效和异步。因此，它们被定义为与相关标准单元寄存器的异步复位输入相关联。</p><p>默认名称是<code>rst_n</code>. 如果必须通过时钟来区分它们，则时钟名称应包含在重置名称中，如<code>rst_domain_n</code>.</p><p>SystemVerilog 允许以下任何一种语法风格，但风格指南更喜欢前者。</p><pre><code>// preferredalways_ff @(posedge clk or negedge rst_n) begin  if (!rst_n) begin    q &lt;= 1'b0;  end else begin    q &lt;= d;  endend// legal but not preferredalways_ff @(posedge clk, negedge rst_n) begin  if (!rst_n) begin    q &lt;= 1'b0;  end else begin    q &lt;= d;  endend</code></pre><h2 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h2><h3 id="首选-SystemVerilog-构造"><a href="#首选-SystemVerilog-构造" class="headerlink" title="首选 SystemVerilog 构造"></a>首选 SystemVerilog 构造</h3><p>使用这些 SystemVerilog 结构而不是它们的 Verilog-2001 等效结构：</p><ul><li><code>always_comb</code>是必需的<code>always @*</code>。</li><li><code>logic</code>优于<code>reg</code>和<code>wire</code>。</li><li>顶级<code>parameter</code>声明优于<code> </code>define`全局声明。</li></ul><h3 id="包依赖"><a href="#包依赖" class="headerlink" title="包依赖"></a>包依赖</h3><p><em><strong>包不能有循环依赖。</strong></em></p><p>包文件可能依赖于其他包文件中的常量和类型，但不能有任何循环依赖。也就是说：如果包 A 依赖于包 B 中的常量，则包 B 不能依赖包 A 中的任何内容。虽然 SystemVerilog 语言规范允许循环依赖，但它们的使用可能会破坏某些工具。</p><p>例如：</p><pre><code>package foo;  // Package "bar" must not depend on anything in "foo":  parameter int unsigned PageSizeBytes = 16 * bar::Kibi;endpackage</code></pre><h3 id="模块声明"><a href="#模块声明" class="headerlink" title="模块声明"></a>模块声明</h3><p><em><strong>使用 Verilog-2001 全端口声明样式，并使用以下格式。</strong></em></p><p>使用 Verilog-2001 组合端口和 I/O 声明样式。不要使用 Verilog-95 列表样式。模块语句中的端口声明应完整声明端口名称、类型和方向。</p><p>左括号应与模块声明在同一行，第一个端口应在下一行声明。</p><p>右括号应该在它自己的行中，在第 0 列中。</p><p>模块声明的缩进遵循两个空格缩进的标准缩进规则。</p><p>时钟端口必须首先在端口列表中声明，然后是任何和所有复位输入。</p><p>无参数示例：</p><p>👍</p><pre><code>module foo (  input              clk_i,  input              rst_ni,  input [7:0]        d_i,  output logic [7:0] q_o);</code></pre><p>带参数的示例：</p><p>👍</p><pre><code>module foo #(  parameter int unsigned Width = 8,) (  input                    clk_i,  input                    rst_ni,  input [Width-1:0]        d_i,  output logic [Width-1:0] q_o);</code></pre><p>不要使用 Verilog-95 样式：</p><p>👎</p><pre><code>// WRONG:module foo(a, b, c d);input wire [2:0] a;output logic b;...</code></pre><h3 id="模块实例化"><a href="#模块实例化" class="headerlink" title="模块实例化"></a>模块实例化</h3><p><em><strong>使用命名端口来完全指定所有实例化。</strong></em></p><p>将信号连接到端口以进行实例化时，请使用命名端口样式，如下所示：</p><pre><code>my_module i_my_instance (  .clk_i (clk_i),  .rst_ni(rst_ni),  .d_i   (from_here),  .q_o   (to_there));</code></pre><p>如果端口和连接信号具有相同的名称，您可以使用 <code>.port</code>语法（不带括号）来表示连接。例如：</p><pre><code>my_module i_my_instance (  .clk_i,  .rst_ni,  .d_i   (from_here),  .q_o   (to_there));</code></pre><p>所有声明的端口都必须存在于实例化块中。未连接的输出必须明确写为无连接（例如：） <code>.output_port()</code>，未使用的输入必须明确接地（例如<code>.unused_input_port(8'd0)</code>：）</p><p><code>.*</code>不允许。</p><p>不要使用位置参数将信号连接到端口。</p><p>按照与模块中定义的顺序相同的顺序实例化端口。</p><p><a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#tabular-alignment">以表格样式</a>对齐端口表达式。不要在最长端口名称的左括号前包含空格。不要在左括号之后或包含端口表达式的右括号之前包含空格。</p><p>👎</p><pre><code>mod u_mod(  .clk_i,  .rst_ni,  // Not allowed: avoid leading/trailing whitespace in expressions.  .sig_1_i( sig_1 ),  .sig_2_i( sig_2 ));mod u_mod(  .clk_i,  .rst_ni,  .short_sig_i                       (sig_1),  // Not allowed: avoid whitespace between the longest signal name and the opening parenthesis.  .a_very_long_signal_name_indeed_i  (sig_2));</code></pre><p><em><strong>对所有实例使用命名参数。</strong></em></p><p>参数化实例时，使用命名参数样式指定参数。一个例外是，如果只有一个参数是显而易见的，例如寄存器宽度，那么实例化可以是隐式的。</p><p>模块实例化的缩进遵循两个空格缩进的标准缩进规则。</p><pre><code>my_module #(  .Height(5),  .Width(10)) my_module (  // ...);my_reg #(16) my_reg0 (  .clk_i,  .rst_ni,  .d_i   (data_in),  .q_o   (data_out));</code></pre><p>不要在位置上指定参数，除非只有一个参数并且该参数的意图很明显，例如寄存器实例的宽度。</p><p>不要使用<code>defparam</code>.</p><p><em><strong>不要递归地实例化。</strong></em></p><p>模块可能不会递归地实例化自己。</p><h3 id="常数-1"><a href="#常数-1" class="headerlink" title="常数"></a>常数</h3><p><em><strong>建议使用符号命名的常量而不是原始数字。</strong></em></p><p>尝试为常用的常量提供符号名称，而不是重复输入原始数字。</p><p>局部常量应始终使用<code>localparam</code>.</p><p>全局常量应始终在单独的文件<code>.vh</code>或<code>.svh</code>包含文件中声明。</p><p>对于 SystemVerilog 代码，应始终将全局常量声明为包参数。对于 Verilog-2001 兼容代码，不支持顶级参数，而<code> </code>define`必须使用宏。</p><p>将常量的单位作为后缀包含在常量的符号名称中。此规则的例外是对于本质上无单位的常量，或者如果常量描述的是默认单位类型“位”。</p><p>例子：</p><pre><code>localparam int unsigned INTERFACE_WIDTH = 64;  // Bitslocalparam int unsigned INTERFACE_WIDTH_BYTES = (INTERFACE_WIDTH + 7) / 8;localparam int unsigned INTERFACE_WIDTH_64B_WORDS = (INTERFACE_WIDTH + 63) / 64;localparam int unsigned IMAGE_WIDTH_PIXELS = 640;localparam int unsigned MEGA = 1000 * 1000;  // Unitlesslocalparam int unsigned MEBI = 1024 * 1024;  // Unitlesslocalparam int unsigned SYSTEM_CLOCK_HZ = 200 * MEGA;</code></pre><h3 id="信号宽度"><a href="#信号宽度" class="headerlink" title="信号宽度"></a>信号宽度</h3><p><em><strong>注意信号宽度。</strong></em></p><h4 id="始终明确数字文字的宽度。"><a href="#始终明确数字文字的宽度。" class="headerlink" title="始终明确数字文字的宽度。"></a>始终明确数字文字的宽度。</h4><p>例子：</p><p>👍</p><pre><code>localparam logic [3:0] bar = 4'd4;assign foo = 8'd2;</code></pre><p>👎</p><pre><code>localparam logic [3:0] bar = 4;assign foo = 2;</code></pre><p>例外：</p><ul><li>使用参数化宽度时，可以简单地使用<code>1'b1</code>（例如，在递增时）而不是像 <code>{{(Bus_width-1){1'b0}}, 1'b1}</code>. 或者，它可以写成<code>Bus_width'(1)</code>.</li><li>使用 ‘0 构造来创建自动正确大小的零是可以接受的。</li><li>分配给整数变量（例如 byte、shortint、int、integer 和 longint）的文字不需要明确的宽度。</li></ul><h4 id="模块实例上的端口连接必须始终正确匹配宽度。"><a href="#模块实例上的端口连接必须始终正确匹配宽度。" class="headerlink" title="模块实例上的端口连接必须始终正确匹配宽度。"></a>模块实例上的端口连接必须始终正确匹配宽度。</h4><p>建议尽可能使用显式宽度，而不是依赖 Verilog 的隐式零扩展和截断操作。</p><p>例子：</p><p>👍</p><pre><code>my_module i_module (  .thirty_two_bit_input({16'd0, sixteen_bit_word}));</code></pre><p>👎</p><pre><code>my_module i_module (  // Incorrectly implicitly extends from 16 bit to 32 bit  .thirty_two_bit_input(sixteen_bit_word));</code></pre><h4 id="不要在布尔上下文中使用多位信号。"><a href="#不要在布尔上下文中使用多位信号。" class="headerlink" title="不要在布尔上下文中使用多位信号。"></a>不要在布尔上下文中使用多位信号。</h4><p>与其让布尔运算和 if 表达式将多位信号简化为单个位，不如将多位信号显式与 0 进行比较。隐式转换可以隐藏细微的逻辑错误。</p><p>例子;</p><p>👍</p><pre><code>logic [3:0] a, b;logic out;assign out = (a != '0) &amp;&amp; (b == '0);always_comb begin  if (a != '0)    ...  else    ...end</code></pre><p>👎</p><pre><code>logic [3:0] a, b;logic out;// Incorrect because it implicitly converts 4-bit signals to 1-bit before AND.// Also, !b is different from ~b and can be hard to catch.assign out = a &amp;&amp; !b;// Incorrect use of a multi-bit signal in an if expressionalways_comb begin  if (a)    ...  else    ...end</code></pre><h4 id="位切片"><a href="#位切片" class="headerlink" title="位切片"></a>位切片</h4><p>仅当意图引用位向量的一部分时才使用位切片运算符。</p><p>例子：</p><p>👍</p><pre><code>logic [7:0] a, b;logic [6:0] c;assign a = 8'd7;       // goodassign a[7:1] = 7'd5;  // good - it's partial assignment.assign a = b;          // good - the parser would warn on width mismatch.</code></pre><p>👎</p><pre><code>logic [7:0] a, b;assign a[7:0] = 8'd7;  // BAD - redundant and can mask linter warnings.assign a = b[7:0];     // BAD - redundant and masks linter warnings.</code></pre><h4 id="处理宽度溢出"><a href="#处理宽度溢出" class="headerlink" title="处理宽度溢出"></a>处理宽度溢出</h4><p>注意移位操作，它会产生比操作数更宽的结果。位选择和连接可能比移动一个恒定量更清楚。</p><p>由于进位，加法和否定运算产生的结果比操作数宽一位。关于匹配宽度的规则的一个允许的例外是默默地放弃继续分配。</p><p>例子：</p><pre><code>logic [3:0] cnt_d, cnt_q;assign cnt_d = cnt_q + 4'h1;</code></pre><p>或者您可以通过使用大小转换来明确表示放弃进位。</p><pre><code>assign cnt_d = 4'(cnt_q + 4'h1);</code></pre><h3 id="阻塞和非阻塞赋值"><a href="#阻塞和非阻塞赋值" class="headerlink" title="阻塞和非阻塞赋值"></a>阻塞和非阻塞赋值</h3><p><em><strong>顺序逻辑必须使用非阻塞赋值。组合块必须使用块分配。</strong></em></p><p>切勿在块声明中混合赋值类型。</p><p>顺序块（在时钟沿锁存状态的块）必须专门使用非块分配，如下面的顺序逻辑部分所定义。</p><p>纯组合块必须专门使用块分配。</p><p>这是 Cliff Cumming 的<a href="http://www.ece.cmu.edu/~ece447/s13/lib/exe/fetch.php?media=synth-verilog-cummins.pdf">Verilog 黄金法则之一</a>。</p><h3 id="延迟建模"><a href="#延迟建模" class="headerlink" title="延迟建模"></a>延迟建模</h3><p><em><strong>不要<code>#delay</code>在可综合的设计模块中使用。</strong></em></p><p>可综合设计模块必须围绕零延迟仿真方法进行设计。不允许使用<code>#delay</code>包括 在内的所有形式。<code>#0</code></p><p>有关详细信息，请参阅 Cliff Cumming 的<a href="http://www.sunburst-design.com/papers/CummingsSNUG2002Boston_NBAwithDelays.pdf">Verilog Nonblocking Assignments With Delays, Myths &amp; Mysteries</a> 。</p><h3 id="顺序逻辑（锁存器）"><a href="#顺序逻辑（锁存器）" class="headerlink" title="顺序逻辑（锁存器）"></a>顺序逻辑（锁存器）</h3><p><em><strong>不鼓励使用锁存器 - 尽可能使用触发器。</strong></em></p><p>除非绝对必要，否则使用触发器/寄存器而不是锁存器。</p><p>如果必须使用锁存器，请使用<code>always_latch</code>over<code>always</code>并使用非阻塞赋值 ( <code>&lt;=</code>)。永远不要使用阻塞赋值 ( <code>=</code>)。</p><h3 id="顺序逻辑（寄存器）"><a href="#顺序逻辑（寄存器）" class="headerlink" title="顺序逻辑（寄存器）"></a>顺序逻辑（寄存器）</h3><p><em><strong>使用标准格式声明顺序块。</strong></em></p><p>在顺序的 always 块中，仅使用非阻塞赋值 ( <code>&lt;=</code>)。永远不要使用阻塞赋值 ( <code>=</code>)。</p><p>将寄存器的阻塞和非阻塞分配混合在一起的设计模拟不正确，因为一些模拟器将始终块中的一些阻塞分配处理为在单独的模拟事件中作为非阻塞分配发生。这个过程使一些信号跳跃寄存器，可能导致完全的质子反转。那很糟。</p><p>状态分配的顺序语句应仅包含重置值和状态分配的下一个状态，使用单独的仅组合块来生成该下一个状态值。</p><p>将实现一个初始值为“0xAB”的正确实现的 8 位寄存器：</p><p>👍</p><pre><code>logic foo_en;logic [7:0] foo_q, foo_d;always_ff @(posedge clk or negedge rst_ni) begin  if (!rst_ni) begin    foo_q &lt;= 8'hab;  end else if (foo_en) begin    foo_q &lt;= foo_d;  endend</code></pre><p>不允许对同一位进行多个非阻塞分配。</p><p>例子：</p><p>👎</p><pre><code>if (cond1) begin  abc &lt;= 4'h1;endif (cond2) begin  abc &lt;= 4'h2;end</code></pre><p>如果 cond1 和 cond2 都为真，则 Verilog 标准规定第二个赋值将生效，但这是违反样式的。</p><p>即使<code>cond1</code>和<code>cond2</code>是互斥的，也要把第二个<code>if</code>变成 <code>else if</code>.</p><p>例外：可以先设置默认值，然后设置特定值。但是，最好在具有显式阻塞分配的单独组合块中完成这项工作。</p><p>例子：</p><pre><code>always_ff @(posedge clk or negedge rst_ni) begin  if (!rst_ni) begin    state_q &lt;= StIdle;  end else begin    state_q &lt;= state_d;  endendalways_comb begin  state_d = state_q;    // default assignment next state is present state  unique case (state_q)    StIdle: state_d = StInit;       // Idle State move to Init    StInit: begin                   // Initialize calculation      if (conditional) begin        state_d = StIdle;      end else begin        state_d = StCalc;      end    end    StCalc: begin                   // Perform calculation      if (conditional) begin        state_d = StResult;      end    end    StResult: state_d = Idle;    default: ;  endcaseend</code></pre><p>保持顺序块中的工作简单。如果顺序块变得足够复杂，请考虑将组合逻辑拆分为单独的组合 ( <code>always_comb</code>) 块。理想情况下，顺序块应该只包含一个寄存器实例，可能带有一个加载使能或一个增量。</p><h3 id="不在乎（X‘s）"><a href="#不在乎（X‘s）" class="headerlink" title="不在乎（X‘s）"></a>不在乎（<code>X</code>‘s）</h3><p><em><strong><code>X</code>强烈建议不要在 RTL 代码中使用文字。在任何情况下， RTL 都不得断言<code>X</code>对综合表示“不关心”。为了标记和检测无效条件，而不是分配和传播<code>X</code>值，设计应该完全定义所有信号值并广泛使用 SVA 来指示无效条件。</strong></em></p><p>如果不严格控制，<code>X</code>在 RTL 中使用分配来标记无效或无关条件可能会导致仿真/综合不匹配。</p><p><strong>鼓励广泛使用 SVA</strong> ，而不是分配和传播<code>X</code>以标记和检测无效条件。这种设计实践的额外好处是：</p><ul><li><code>X</code>正确传播条件不需要特殊的代码样式，</li><li>系统地减少了意外引入模拟/综合失配的机会，</li><li>模拟会很快失败，并且需要更少的信号回溯来解决根本原因错误，</li><li>在某些情况下，可以使用形式属性验证 (FPV) 来证明这些 SVA 是否始终能够得到满足，</li><li>在安全上下文中，需要确定性/定义的行为，即使对于非法/无效/无法访问的输入组合（有时更简洁地表述为“对于安全关键设计，没有无关紧要”）。</li></ul><p>这里提出的解决方案与Don Mills在<a href="http://www.lcdm-eng.com/papers/snug04_assertiveX.pdf">“Being Assertive With Your X”</a>中提出的方法有相似之处 。</p><p>请注意，尽管 don’t cares 可用于指示综合工具可能的优化机会，但逻辑缩减的收益是否足以超过使用<code>X</code>文字可能带来的综合不匹配问题（尤其是使用当今技术中可用的门数）。</p><h4 id="捕获使用无效值的错误"><a href="#捕获使用无效值的错误" class="headerlink" title="捕获使用无效值的错误"></a>捕获使用无效值的错误</h4><p>对于内部生成的可能无效（但未驱动到<code>X</code>）的信号并用于触发某些操作（例如寄存器写使能），建议添加断言以检查当使能为真时，信号有效。当意外使用无效值时，这会触发简单的故障诊断。</p><pre><code>logic reg_addr;logic reg_wr_en;// internal logic which generates reg_addr/reg_wr_en reg_en_addr will never// be X but must be ignored if reg_wr_en == 0assign reg_addr = ...assign reg_wr_en = ......// trigger some specific action when a certain register is writtenlogic special_reg_en;assign special_reg_en = (reg_addr == SPECIAL_REG_ADDR) &amp; reg_wr_en;// Aim to keep RHS of implication as broad as possible`ASSERT(NoSpecialRegEnWithoutRegEn, special_reg_en |-&gt; reg_wr_en);</code></pre><p>其中值及其有效性信号由 DV 环境生成，该环境将驱动<code>X</code>无效信号``ASSERT_KNOWN`就足够了。</p><pre><code>module mymod (  input [7:0] external_addr_i,  input       external_wr_en_i);  logic special_action_en;  assign special_action_en =      (external_addr_i == SPECIAL_ADDR) &amp; external_wr_en_i;  `ASSERT_KNOWN(special_action_en)endmodule</code></pre><h4 id="案例陈述和三元组的具体指导"><a href="#案例陈述和三元组的具体指导" class="headerlink" title="案例陈述和三元组的具体指导"></a>案例陈述和三元组的具体指导</h4><p>为了符合这种风格，RTL 必须<code> </code>ASSERT_KNOWN<code>对所有模块输出进行断言，但可能隐含</code>X`在仿真开始时的信号除外，例如 FIFO、SRAM 或寄存器文件输出。</p><pre><code>module mymod (  input        ina_i,  input        inb_i,  output logic out_o);  assign out_o = ina_i ^ inb_i;  `ASSERT_KNOWN(OutKnown_A, out_o, clk_i, !rst_ni)endmodule : mymod</code></pre><p>此外，鼓励将断言添加到形成 case 语句、三元组或 if/else 语句的条件的信号中。断言样式由设计者自行决定，范围可以从简单<code> </code>ASSERT_KNOWN` 断言到功能齐全的断言，如以下示例所示：</p><pre><code>typedef enum logic [1:0] {mode0, mode1, mode2} state_e;state_e sel;// encouraged`ASSERT_KNOWN(SelKnown_A, sel)always_comb begin  out0 = '0;  out1 = '0;  unique case (sel)    mode1: out0 = foo;    mode2: out1 = bar;    default: ;  endcaseend// optional, but more explicit// not always applicable`ASSERT(MainFsmCase_A, sel inside {mode0, mode1, mode2}, clk_i, !rst_ni)always_comb begin  out0 = '0;  out1 = '0;  unique case (sel)    mode1: out0 = foo;    mode2: out1 = bar;    default: ;  endcaseend</code></pre><p>在三元语句的上下文中，鼓励使用以下示例：</p><pre><code>// encouraged`ASSERT_KNOWN(ModeKnown_A, mode_i, clk_i, !rst_ni)`ASSERT_KNOWN(LenKnown_A, len_i, clk_i, !rst_ni)// assign '0 for all other combinationsassign val = (mode_i == ENC)                    ? 8'h01 :             (mode_i == DEC &amp;&amp; len_i == LEN128) ? 8'h36 :             (mode_i == DEC &amp;&amp; len_i == LEN192) ? 8'h80 :             (mode_i == DEC &amp;&amp; len_i == LEN256) ? 8'h40 : 8'h00;// optional, but more explicit`ASSERT(ValSelValid_A, mode_i == ENC || mode_i == DEC &amp;&amp;    len_i inside {LEN128, LEN192, LEN256}, clk_i, !rst_ni)// using one of the valid outputs for other combinations (saves logic)assign val = (mode_i == ENC)                    ? 8'h01 :             (mode_i == DEC &amp;&amp; len_i == LEN128) ? 8'h36 :             (mode_i == DEC &amp;&amp; len_i == LEN192) ? 8'h80 :             (mode_i == DEC &amp;&amp; len_i == LEN256) ? 8'h40 : 8'h01;</code></pre><p>请注意，在某些情况下，输入到 case 或 ternary 可能是<code>X</code> 但仅在无关紧要的情况下，因为输出将被忽略，因为未设置一些符合输入的有效信号。例如，输入可以直接来自存储器或来自 DV 环境驱动的顶级输入<code>X</code>。在这些情况下， plain``ASSERT_KNOWN`将不起作用，并且使用具有某些限定有效的断言是合适的：</p><pre><code>`ASSERT(AddrKnownIfValid, addr_valid |-&gt; !$isunknown(addr))always_comb begin  out = '0  unique case (addr[1:0])    ConstAddr1: out = foo;    ConstAddr2: out = bar;    default:    out = baz;  endcaseend</code></pre><p>目的应该是使合格的有效信号尽可能广泛，而不是缩小<code>X</code>检查范围超出要求：</p><p>👎</p><pre><code>`ASSERT(AddrKnownIfValid,  addr_valid &amp; internal_condition_1 &amp; internal_condition_2 |-&gt;  !$isunknown(addr))</code></pre><h4 id="动态数组索引"><a href="#动态数组索引" class="headerlink" title="动态数组索引"></a>动态数组索引</h4><p>需要注意的是，动态数组索引操作可以隐式导致 <code>X</code>. 如果可能，应通过将索引数组对齐到 2 的幂或通过在索引操作周围添加保护 if 语句来避免这种情况。这些解决方案在以下示例中进行了说明。</p><p>👎</p><pre><code>logic selected;logic [3:0] idx;logic [11:0] foo; // problematicassign foo = {12'b1010_1111_0000};assign selected = foo[idx];</code></pre><p>👍</p><pre><code>logic selected;logic [3:0] idx;logic [15:0] foo; // aligned to powers of twoassign foo = {4'b0000, 12'b1010_1111_0000};assign selected = foo[idx];</code></pre><p>👍</p><pre><code>logic selected;logic [3:0] idx;logic [11:0] foo;assign foo = {12'b1010_1111_0000};// guarding if statementassign selected = (idx &lt; $bits(foo)) ? foo[idx] : 1'b0;</code></pre><h3 id="组合逻辑"><a href="#组合逻辑" class="headerlink" title="组合逻辑"></a>组合逻辑</h3><p><em><strong>避免敏感度列表，并使用一致的分配类型。</strong></em></p><p>用于<code>always_comb</code>SystemVerilog 组合块。<code>always @*</code>如果仅支持 Verilog-2001，则使用。永远不要明确声明组合逻辑的敏感性列表。</p><p>在可行的情况下首选分配语句。</p><p>例子：</p><pre><code>assign final_value = xyz ? value_a : value_b;</code></pre><p>如果需要 case 语句，请将其包含在自己的<code>always_comb</code>块中。</p><p>可综合的组合逻辑块应该只使用阻塞赋值。</p><p>不要使用三态逻辑（<code>Z</code>state）来完成多路复用等片上逻辑。</p><p>不要在函数内部推断锁存器，因为这可能会导致模拟/综合不匹配。</p><h3 id="案例陈述"><a href="#案例陈述" class="headerlink" title="案例陈述"></a>案例陈述</h3><p><em><strong>避免修改大小写的编译指示。<code>unique case</code>是最佳实践。始终定义默认情况。</strong></em></p><p>永远不要使用 the<code>full_case</code>或<code>parallel_case</code>pragma。这些 pragma 很容易导致综合仿真不匹配。</p><p>下面是一个符合样式的完整 case 语句示例：</p><pre><code>always_comb begin  unique casez (select)    3'b000: operand = accum0 &gt;&gt; 0;    3'b001: operand = accum0 &gt;&gt; 1;    3'b010: operand = accum1 &gt;&gt; 0;    3'b011: operand = accum1 &gt;&gt; 1;    3'b1??: operand = regfile[select[1:0]];    default: operand = '0; // assign a default  endcaseend</code></pre><p>建议在所有 case 语句之前使用<code>unique</code>前缀，因为它会创建可以捕获某些错误的模拟断言。在某些情况下，<code>priority</code> 可以使用 代替<code>unique</code>，但在这种情况下，级联三元结构应该是表示优先级编码器的首选方式，因为它们是优先级编码器的更易读的表示。</p><p>一定要<code>unique case</code>正确使用。特别要确保：</p><ul><li><strong>始终</strong>包含一个<code>default:</code>语句以避免意外推断闩锁，即使涵盖了所有情况。在模拟中，计算结果为的 case 表达式将不匹配任何 case 并且将充当锁存器，如果未指定默认值，则会导致与综合不同的行为。<code>X</code></li><li>如上例所示，如果在 case 语句之前没有给出默认赋值，则在一个 case 项中分配的任何变量都必须在所有 case 项中分配，包括<code>default:</code>. 不这样做可能会导致模拟综合不匹配，如<a href="http://www.lcdm-eng.com/papers/snug12_Paper_final.pdf">Don Mills 的论文</a>中所述。</li></ul><p>以下是一个不同的示例，显示了一个符合样式的 case 语句变体，该变体经常用于描述有限状态机的下一个状态逻辑。与前面的示例不同的是，默认分配放在<code>unique case</code>块之前，因此可以在下面的个别情况下省略常见的分配。如果不是在 case 语句之前进行常见的默认分配，则必须在所有情况下为所有变量分配一个值，<code>default:</code>以防止模拟-综合不匹配。</p><pre><code>always_comb begin  // common default assignments  state_d = state_q;  outa = 1'b0;  outb = 1'b0;  outc = 1'b0;  unique case (state_q)    Idle: begin      state_d = Work;      outa = in0;    end    Work: begin      state_d = Wait;      outb = in1;    end    Wait: begin      state_d = Idle;      outc = in2;    end    // always include a default case    // empty default permissible due to defaults before case block    default: ;  endcaseend</code></pre><h4 id="案例项目中的通配符"><a href="#案例项目中的通配符" class="headerlink" title="案例项目中的通配符"></a>案例项目中的通配符</h4><p><code>case</code>如果不需要通配符运算符行为，请使用。<code>case inside</code>如果需要通配符运算符行为，请使用。如果<code>casez</code>需要通配符运算符行为并且需要 Verilog-2001 兼容性，则使用此选项。</p><p>在案例项目中表示通配符时，请使用“？” 字符，因为它更清楚地表达了意图。</p><p><code>casex</code>不应该使用。<code>casex</code>实现了一个对称通配符运算符，这样一个<code>X</code>in case 表达式可以匹配一个或多个 case 项。 <code>casez</code>仅将高阻抗状态 (<code>Z</code>或<code>?</code>) 视为通配符，并对未驱动的<code>X</code>输入执行完全匹配。虽然这并不能完全解决对称通配符匹配的问题，但意外产生<code>Z</code>输入比<code>X</code>输入更难，因此首选这种形式。 <code>case inside</code>不会将case 表达式<code>X</code>或<code>Z</code>case 表达式视为通配符，因此这种形式优于<code>casez</code>.</p><p>参考：</p><ul><li>Don Mills，<a href="http://www.lcdm-eng.com/papers/snug12_Paper_final.pdf">又一个闩锁和陷阱纸</a></li><li>Clifford Cummings，<a href="http://www.sunburst-design.com/papers/CummingsSNUG1999Boston_FullParallelCase_rev1_1.pdf">full_case parallel_case，Verilog 综合的邪恶双胞胎</a></li><li>Clifford Cummings，<a href="http://www.sunburst-design.com/papers/CummingsSNUG2005Israel_SystemVerilog_UniquePriority.pdf">SystemVerilog 的优先级和独特性</a></li><li>Sutherland、Mills 和 Spear，[再次遇到问题：每个工程师都应该知道的 Verilog 和 SystemVerilog 标准中的更多细微之处](<a href="http://www.lcdm-eng.com/papers/snug07_Verilog">http://www.lcdm-eng.com/papers/snug07_Verilog</a> Gotchas Part2.pdf)</li></ul><h3 id="生成构造"><a href="#生成构造" class="headerlink" title="生成构造"></a>生成构造</h3><p><em><strong>始终命名您生成的块。</strong></em></p><p>使用 generate 构造时，始终明确命名每个生成代码块。命名生成 if 语句的每个可能结果，并命名生成 for 语句的迭代块。</p><p>这可确保生成的分层信号名称在不同工具之间保持一致。</p><p>生成和所有命名的代码块都应该使用<code>lower_snake_case</code>. 应<code>begin</code>在代码块名称和代码块名称之间放置一个空格。</p><p>条件生成构造示例：</p><p>👍</p><pre><code>if (TypeIsPosedge) begin : posedge_type  always_ff @(posedge clk) foo &lt;= bar;end else begin : negedge_type  always_ff @(negedge clk) foo &lt;= bar;end</code></pre><p>循环生成构造示例：</p><p>👍</p><pre><code>for (genvar ii = 0; ii &lt; NumberOfBuses; ii++) begin : my_buses  my_bus #(.index(ii)) i_my_bus (.foo(foo), .bar(bar[ii]));end</code></pre><p>不要使用附加<code>begin</code>块包装生成构造。</p><p>不要使用生成区域 { <code>generate</code>, <code>endgenerate</code>}。</p><h3 id="有符号算术"><a href="#有符号算术" class="headerlink" title="有符号算术"></a>有符号算术</h3><p><em><strong>在使用有符号算术的地方使用可用的有符号算术结构。</strong></em></p><p>当需要从无符号转换为有符号时，请使用强制转换<code>signed'</code>运算符（<code>$signed</code>在 Verilog-2001 中）。</p><p>如果计算中的任何操作数是无符号的，Verilog 会隐式地将所有操作数转换为无符号并生成警告。如果正确转换了所有无符号变量，则仿真或综合工具不应有任何有符号到无符号的警告。</p><p>隐式有符号到无符号转换的示例：</p><pre><code>logic signed [7:0]  a;logic               incr;logic signed [15:0] sum1, sum2, sum3;initial begin  a = 8'sh80;                        // a = -128  incr = 1'b1;  sum1 = a + incr;                   // bad:  sum1 = 16'h0081 ( 129)  sum2 = a + signed'({1'b0, incr});  // good: sum2 = 16'hFF81 (-127)  sum3 = a + 8'sh01;                 // good: sum3 = sum2 (more straightforward)end</code></pre><p>在上面的示例中，无符号的事实也<code>incr</code>导致<code>a</code>评估为无符号。该<code>sum1</code>评估令人惊讶，并带有不应忽略的警告标记。</p><h3 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h3><p><em><strong>用 .前缀打印的二进制数<code>0b</code>。用 . 前缀打印的十六进制数字<code>0x</code>。不要为十进制数字使用前缀。</strong></em></p><p>在为日志文件格式化数字的文本表示时，请明确您包含哪些数据。</p><p>使打印数字的基础清晰。只打印不带修饰符的十进制数字。<code>0x</code>对十六进制使用前缀，<code>0b</code>对二进制使用前缀。</p><p>单独解码大型结构的各个字段，而不是期望用户手动解码原始值。</p><p>👍</p><pre><code>$display("0x%0x", some_hex_value);$display("0b%0b", some_binary_value);$display("%0d",   some_decimal_value);</code></pre><p>👎</p><pre><code>$display("%0x",   some_hex_value);$display("%0b",   some_binary_value);$display("0d%0d", some_decimal_value);</code></pre><p>分配常量值时，为了更好的可读性，最好对长度超过 8 的十六进制或二进制位强度使用下划线表示法。除非提高可读性，否则不需要零前缀。以它们通常显示的格式（二进制、十六进制、十进制）声明常量。</p><p>👍</p><pre><code>logic [15:0] val0, val1, val2;logic [39:0] addr0, addr1;always_comb begin  val0 = 16'h0;  if (condition1) begin    val1  = 16'b0010_0011_0000_1101;    val2  = 16'b0010_1100_0000_0000;    addr1 = 40'h00_1fc0_0000;    addr2 = 40'h00_efc0_0000;  end else begin    val0  = 16'hffff;    val1  = 16'b1010_0011_0110_1001;    val2  = 16'b1110_1100_1111_0110;    addr1 = 40'h40_8000_0000;    addr2 = 40'h41_c000_0000;  endend</code></pre><h3 id="功能和任务"><a href="#功能和任务" class="headerlink" title="功能和任务"></a>功能和任务</h3><p>以下部分仅适用于可综合 RTL。请参阅用于 DV 使用<a href="https://github.com/lowRISC/style-guides/blob/master/DVCodingStyle.md">的设计验证的编码风格指南。</a></p><p><em><strong>在可综合的 RTL 中，只要声明了函数，就可以使用函数 <code>automatic</code>。不应使用任务。</strong></em></p><p>函数必须在包或模块中声明。一个包适用于函数与包中的其他定义相关的情况，并且可能对多个模块有用（即使它当前仅由一个模块使用）。模块适用于功能与该模块的内部特别相关的情况。</p><p>函数的目标应该是在概念上表示一个可重用的组合逻辑块。</p><p>必须为所有参数和函数返回值显式声明存储类型。所有类型都必须是 4 态数据类型，或者<code>logic</code>派生自的类型<code>logic</code>（例如适当<code>struct</code>的<code>enum</code>或<code>typedef</code>类型）。</p><p>不要在函数参数上使用<code>output</code>、、<code>inout</code>或。<code>ref</code>所有功能都应该只消耗输入并产生一个输出。<code>input</code>是默认值，函数参数不需要。</p><p>👎</p><pre><code>// - Doesn't have explicit storage type on `a` or `b` or return type// - `b` being used as `output` argument// - `input` not required on `a`function automatic [2:0] foo(input [2:0] a, [2:0] b);  b = b + 1;  return a + b;endfunction</code></pre><p>👎</p><pre><code>// - Doesn't have explicit storage type on `a`, `b` or `c`// - Uses `output` on `c`// - `input` not required on `a` and `b`function automatic logic [2:0] foo(input [2:0] a, input [2:0] b, output [2:0] c);  c = a - b;  return a + b;endfunction</code></pre><p>👎</p><pre><code>// - Uses 2-state data type `int` for `a`function automatic logic [2:0] foo(int a, logic [2:0] b);  return a + b;endfunction</code></pre><p>👍</p><pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b); return a ^ b;endfunction</code></pre><p>👍</p><pre><code>typedef logic [2:0] bar_t;typedef struct packed {  logic [2:0] field;} baz_t;function automatic logic [2:0] foo(bar_t a, baz_t b);  return a + b.field;endfunction</code></pre><p>应该使用显式<code>return result</code>样式从函数返回数据。不要使用<code>function_name = result</code>样式。</p><p>👎</p><pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);  if (a == 3'd2) begin    foo = b;  end else begin    foo = a ^ b;  endendfunction</code></pre><p>👍</p><pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);  logic [2:0] result;  if (a == 3'd2) begin    result = b;  end else begin    result = a ^ b;  end  return result;endfunction</code></pre><p>必须在所有代码路径中分配所有局部变量，通过初始分配或通过使用<code>else</code>and <code>default:</code>for<code>if</code>和 <code>case</code>语句。</p><p>👍</p><pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);  logic [2:0] local_var_1;  logic [2:0] local_var_2;  local_var_1 = 3'd0;  if (a == 0) begin    local_var_1 = 3'd2;  end  unique case(b)    3'd0:    local_var_2 = 3'd1;    3'd1:    local_var_2 = 3'd3;    default: local_var_2 = 3'd0;  endcase  return local_var_1 + local_var_2;endfunction</code></pre><p>👎</p><pre><code>function automatic logic [2:0] foo(logic [2:0] a, logic [2:0] b);  logic [2:0] local_var_1;  logic [2:0] local_var_2;  if (a == 0) begin    local_var_1 = 3'd2;  end  unique case(b)    3'd0:    local_var_2 = 3'd1;    3'd1:    local_var_2 = 3'd3;  endcase  return local_var_1 + local_var_2;endfunction</code></pre><h3 id="有问题的语言特征和结构"><a href="#有问题的语言特征和结构" class="headerlink" title="有问题的语言特征和结构"></a>有问题的语言特征和结构</h3><p>这些语言特性被认为是有问题的，除非另有说明，否则不鼓励使用它们：</p><ul><li>接口。</li><li><code>alias</code>声明。</li></ul><h4 id="浮动起始块"><a href="#浮动起始块" class="headerlink" title="浮动起始块"></a>浮动起始块</h4><p>使用除<code>for</code>循环之外的生成块<code>if</code>，或<code>case</code>生成构造不符合 LRM。虽然某些工具可能会接受这种用法，但本指南禁止这种“裸”生成块。请注意，类似的“顺序块”构造符合 LRM 并被允许。</p><p>👎</p><pre><code>module foo (  input bar,  output foo);  begin // illegal generate block    assign foo = bar;  endendmodule</code></pre><h4 id="分层引用"><a href="#分层引用" class="headerlink" title="分层引用"></a>分层引用</h4><p>禁止在可综合的 RTL 代码中使用分层引用。某些综合工具确实支持分层引用，而一些工具会出错，而其他工具可能会默默地忽略它们，这可能会导致仿真/综合不匹配。</p><p>一个例外情况是分层引用由宏保护以将它们移除以进行综合，例如，作为 SystemVerilog 断言 (SVA) 的一部分。</p><p>👎</p><pre><code>module mymod_int (  input        in0_i,  input        in1_i,  input        in2_i,  output logic out_o);  logic int;  assign int   = in0_i &amp; in1_i;  assign out_o = in2_i | int;endmodulemodule mymod (  ...);  mymod_int u_mymod_int (    .in0_i,    .in1_i,    .in2_i,    .out_o  );  // Hierarchical references are prohibited in synthesizable RTL code.  assign int_o = u_mymod_int.int;endmodule</code></pre><h2 id="设计惯例"><a href="#设计惯例" class="headerlink" title="设计惯例"></a>设计惯例</h2><h3 id="概括-3"><a href="#概括-3" class="headerlink" title="概括"></a>概括</h3><p>本节的主要思想包括：</p><ul><li>声明所有信号并使用<code>logic</code>：<code>logic foo;</code></li><li>打包数组是小端的：<code>logic [7:0] byte;</code></li><li>未打包的数组是大端的：<code>byte_t arr[0:N-1];</code></li><li>首选注册模块输出。</li><li>一致地声明 FSM。</li></ul><h3 id="声明所有信号"><a href="#声明所有信号" class="headerlink" title="声明所有信号"></a>声明所有信号</h3><p><em><strong>不要依赖推断的网络。</strong></em></p><p>所有信号<strong>必须</strong>在使用前显式声明。所有声明的信号都必须指定数据类型。正确的设计不包含推断网络。</p><h3 id="用于logic合成"><a href="#用于logic合成" class="headerlink" title="用于logic合成"></a>用于<code>logic</code>合成</h3><p><em><strong>用于<code>logic</code>合成。<code>wire</code>必要时允许。</strong></em></p><p>可综合 RTL 中的所有信号都必须根据 4 状态数据类型来实现。这意味着所有信号最终都必须由存储类型为<code>logic</code>. 虽然 SystemVerilog 确实为其他数据原语提供了 4 状态存储（即<code>integer</code>），但这些原语很容易产生误解和误用。</p><p>例如：</p><p>👍</p><pre><code>logic signed [31:0] x_velocity;  // say what you mean: a signed 32-bit integer.typedef logic [7:0] byte_t;</code></pre><p>👎</p><pre><code>bit signed [63:0] stars_in_the_sky;  // 2-state logic doesn't belong in RTLint grains_of_sand;  // Or wait, did I mean integer?  Easy to confuse!</code></pre><p>允许使用线作为简写来声明网络和执行连续分配。注意不要将连续赋值与初始化混淆。例如：</p><p>👍</p><pre><code>wire [7:0] sum = a + b;  // Continuous assignment</code></pre><p>👎</p><pre><code>logic [7:0] sum = a + b; // Initialization (not synthesizable)</code></pre><p><code>sum</code>被初始化为 a 和 b 的初始值之和。</p><p>👍</p><pre><code>logic [7:0] acc = '0;    // Initialization (synthesizable on some FPGA tools)</code></pre><p><code>logic</code>不合适的地方也有例外。例如，连接到双向 ( <code>inout</code>) 端口的网络必须用 声明<code>wire</code>。应该用简短的评论来证明这些例外是合理的。</p><p>DV（设计验证）允许使用 2 态逻辑，但 4 态和 2 态信号之间的所有接口必须<code>X</code>在解析为 2 态变量之前断言对 4 态网络的检查。</p><h3 id="逻辑与按位"><a href="#逻辑与按位" class="headerlink" title="逻辑与按位"></a>逻辑与按位</h3><p><em><strong>首选逻辑结构进行逻辑比较，按位进行数据。</strong></em></p><p>逻辑运算符 ( <code>!</code>, <code>||</code>, <code>&amp;&amp;</code>, <code>==</code>, <code>!=</code>) 应用于评估逻辑（真或假）值的所有构造，例如 if 子句和三元赋值。对所有数据结构都优先使用按位运算符 ( <code>~</code>, <code>|</code>, <code>&amp;</code>, <code>^</code>)，即使是标量。在很明显要在逻辑上下文中使用评估表达式的情况下可以例外。</p><p>👍</p><pre><code>always_ff @(posedge clk_i or negedge rst_ni) begin  if (!rst_ni) begin    reg_q &lt;= '0;  end else begin    reg_q &lt;= reg_d;  endendalways_comb begin  if (bool_a || (bool_b &amp;&amp; !bool_c) begin    x = 1'b1;  end else begin    x = 1'b0;endassign z = ((bool_a != bool_b) || bool_c) ? a : b;assign y = (a &amp; ~b) | c;</code></pre><p>👎</p><pre><code>always_ff @(posedge clk_i or negedge rst_ni) begin  if (~rst_ni) begin    reg_q &lt;= '0;  end else begin    reg_q &lt;= reg_d;  endendalways_comb begin  if (bool_a | (bool_b &amp; ~bool_c) begin    x = 1'b1;  end else begin    x = 1'b0;endassign z = ((bool_a ^ bool_b) | bool_c) ? a : b;assign y = (a &amp;&amp; !b) || c;</code></pre><p>👍</p><pre><code>// allowed logical assignment for boolean testassign request_valid = !fifo_empty &amp;&amp; data_available;always_comb begin  if (request_valid) begin    output_valid = 1'b1;  end else begin    output_valid = 1'b0;  endend</code></pre><h3 id="打包订购"><a href="#打包订购" class="headerlink" title="打包订购"></a>打包订购</h3><p><em><strong>位向量和压缩数组必须是 little-endian。</strong></em></p><p>声明位向量和压缩数组时，最高有效界限（冒号左侧）的索引必须大于或等于最低有效界限（冒号右侧）。</p><p>这种位向量声明风格保持压缩变量 little-endian。</p><p>例如：</p><pre><code>typedef logic [7:0] u8_t;logic [31:0] u32_word;u8_t [1:0] u16_word;u8_t byte3, byte2, byte1, byte0;assign u16_word = {byte1, byte0};assign u32_word = {byte3, byte2, u16_word};</code></pre><h3 id="无包装订购"><a href="#无包装订购" class="headerlink" title="无包装订购"></a>无包装订购</h3><p><em><strong>解压的数组必须是大端的。</strong></em></p><p>以大端方式声明解包数组（例如，<code>[n:m]</code>where <code>n &lt;= m</code>）。永远不要以 little-endian 顺序声明未打包的数组，例如 <code>[size-1:0]</code>.</p><p>使用较短的符号声明从零开始的解包数组<code>[size]</code>。据了解，<code>[size]</code>相当于大端声明 <code>[0:size-1]</code>。</p><pre><code>logic [15:0] word_array[3] = '{word0, word1, word2};</code></pre><h3 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h3><p><em><strong>状态机使用枚举来定义状态，并通过两个进程块实现：组合块和时钟块。</strong></em></p><p>每个状态机描述都包含三个部分：</p><ol><li>声明和描述状态的枚举。</li><li>一个组合过程块，它对状态进行解码以产生下一个状态和其他组合输出。</li><li>从下一个状态更新状态的时钟进程块。</li></ol><p><em>枚举状态</em></p><p>状态机的枚举语句应该列出状态机中的每个状态。描述状态的注释应推迟到下面组合过程块中的 case 语句。</p><p><code>UpperCamelCase</code>与其他 <a href="https://github.com/lowRISC/style-guides/blob/master/VerilogCodingStyle.md#enumerations">枚举常量</a>一样，应以 in 命名状态。</p><p>除非有特殊情况，状态机的初始空闲状态将被命名为<code>Idle</code>or <code>StIdle</code>。（如果可以提高清晰度，则可以使用替代名称。）</p><p>理想情况下，每个模块应该只包含一个状态机。如果您的模块需要多个状态机，则需要为每个状态机的状态添加唯一的前缀（或后缀），以区分哪个状态与哪个状态机相关联。例如，具有“读取器”机器和“写入器”机器的模块可能具有<code>StRdIdle</code>状态和<code>StWrIdle</code>状态。</p><p><em>国家组合解码</em></p><p>组合过程块应包含：</p><ul><li>解码状态以产生下一个状态和组合输出的 case 语句。为清楚起见，仅应编码输出值偏离默认值的情况。</li><li>在 case 语句之前应该是一段代码，为每个组合输出定义默认值，包括“下一个状态”。</li><li>“下一个状态”变量的默认值应该是当前状态。然后，在状态之间转换时，解码状态的 case 语句将只分配给“下一个状态”。</li><li>在 case 语句中，每个状态选择之前都应该有一个注释，描述该状态在状态机中的功能。</li></ul><p><em>国家登记册</em></p><p>在此过程中不应执行除复位之外的任何逻辑。状态变量应该锁存“下一个状态”变量的值。</p><p><em>其他指南</em></p><p>如果可能，请尝试在名称开头附近选择不同的状态名称，以使它们在查看波形轨迹时更具可读性。</p><p><em>例子</em></p><p>👍</p><pre><code>// Define the statestypedef enum {  StIdle, StFrameStart, StDynInstrRead, StBandCorr, StAccStoreWrite, StBandEnd} alcor_state_e;alcor_state_e alcor_state_d, alcor_state_q;// Combinational decode of the statealways_comb begin  alcor_state_d = alcor_state_q;  foo = 1'b0;  bar = 1'b0;  bum = 1'b0;  unique case (alcor_state_q)    // StIdle: waiting for frame_start    StIdle:      if (frame_start) begin        foo = 1'b1;        alcor_state_d = StFrameStart;      end    // StFrameStart: Reset accumulators    StFrameStart: begin      // ... etc ...    end    // may be empty or used to catch parasitic states    default: alcor_state_d = StIdle;  endcaseend// Register the statealways_ff @(posedge clk or negedge rst_n) begin  if (!rst_n) begin    alcor_state_q &lt;= StIdle;  end else begin    alcor_state_q &lt;= alcor_state_d;  endend</code></pre><h3 id="低电平有效信号"><a href="#低电平有效信号" class="headerlink" title="低电平有效信号"></a>低电平有效信号</h3><p><em><strong><code>_n</code>后缀表示低电平有效信号。</strong></em></p><p>如果使用低电平有效信号，它们<code>_n</code>的名称中必须有后缀。否则，所有信号都假定为高电平有效。</p><h3 id="差分对"><a href="#差分对" class="headerlink" title="差分对"></a>差分对</h3><p><em><strong>使用<code>_p</code>和<code>_n</code>后缀表示差分对。</strong></em></p><p>例如，<code>in_p</code>包括<code>in_n</code>一个差分对组。</p><h3 id="延误"><a href="#延误" class="headerlink" title="延误"></a>延误</h3><p><em><strong>延迟一个时钟周期的信号应以<code>_q</code>后缀结尾。</strong></em></p><p>如果一个信号只是另一个信号的延迟版本，<code>_q</code>则应使用后缀来表示这种关系。</p><p>如果另一个信号随后被另一个时钟周期延迟，则应使用<code>_q2</code>后缀标识下一个信号<code>_q3</code>，以此类推。</p><p>例子：</p><pre><code>always_ff @(posedge clk) begin  data_valid_q &lt;= data_valid_d;  data_valid_q2 &lt;= data_valid_q;  data_valid_q3 &lt;= data_valid_q2;end</code></pre><h3 id="包的通配符导入"><a href="#包的通配符导入" class="headerlink" title="包的通配符导入"></a>包的通配符导入</h3><p>通配符导入语法，例如<code>import ip_pkg::*;</code>，仅在包与使用该包的模块属于同一 IP 的情况下才允许使用。通配符导入语句必须放在模块头或模块体中。</p><p>👍</p><pre><code>// mod_a_pkg.sv and mod_a.sv are in the same IP.// Packages can be imported in the module declaration if access to// unqualified types is needed in the port list.// mod_a_pkg.svpackage mod_a_pkg;  typedef struct packed {    ...  } a_req_t;endpackage// mod_a.svmodule mod_a  import mod_a_pkg::*;(  ...  a_req_t a_req,  ...);endmodule</code></pre><p>👍</p><pre><code>// mod_amodule mod_a ();  // mod_a_pkg.sv and mod_a.sv are in the same IP.  import mod_a_pkg::*;  ...  a_req_t a_req;endmodule</code></pre><p>除上述情况外，不允许通配符导入。例如，下面的示例可能会<code>mod_a</code> 在源列表中的模块中创建名称冲突。</p><p>👎</p><pre><code>// mod_a.svimport mod_a_pkg::*; // not allowed: imported to $root scope.module mod_a ();endmodule</code></pre><p>其他不好的例子：</p><p>👎</p><pre><code>// wildcard import for other packages outside of the IPmodule mod_a import mod_b_pkg::*; ();</code></pre><p>👎</p><pre><code>module mod_a ();  // not allowed: wildcard import of a package from a different IP  import mod_b_pkg::*;endmodule</code></pre><h3 id="断言宏"><a href="#断言宏" class="headerlink" title="断言宏"></a>断言宏</h3><p>鼓励在整个设计中使用 SystemVerilog 断言 (SVA) 来检查功能正确性并标记无效条件。为了提高生产力并保持断言简洁明了，可以使用以下断言宏：</p><pre><code>// immediate assertion, to be placed within a process.`ASSERT_I(&lt;name&gt;, &lt;property&gt;)// immediate assertion wrapped within an initial block. can be used for things// like parameter checking.`ASSERT_INIT(&lt;name&gt;, &lt;property&gt;)// concurrent assertion to be used for functional assertions.`ASSERT(&lt;name&gt;, &lt;property&gt;, &lt;clk&gt;, &lt;reset condition&gt;)// concurrent assertion that checks that a signal has a known value after reset// (i.e. that the signal is not `X`).`ASSERT_KNOWN(&lt;name&gt;, &lt;signal&gt;, &lt;clk&gt;, &lt;reset condition&gt;)</code></pre><p>这些宏的实现（包括其他有用的变体）可以在这里找到： <a href="https://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv">https ://github.com/lowRISC/opentitan/blob/master/hw/ip/prim/rtl/prim_assert.sv</a></p><h4 id="关于安全关键应用程序的说明"><a href="#关于安全关键应用程序的说明" class="headerlink" title="关于安全关键应用程序的说明"></a>关于安全关键应用程序的说明</h4><p>对于安全关键应用程序，涉及保护 case 语句和三元组的断言宏的名称应以<code>_SEC</code>. 这可以在设计过程的后期阶段对这些语句进行特定于安全性的后处理。就功能而言，这些宏应该与原始断言相同，即</p><pre><code>`define ASSERT_SEC `ASSERT`define ASSERT_I_SEC `ASSERT_I`define ASSERT_KNOWN_SEC `ASSERT_KNOWN</code></pre><p>很快，将在单独的文档中提供更多安全断言和编码风格指南。</p><h2 id="附录-精简风格指南"><a href="#附录-精简风格指南" class="headerlink" title="附录 - 精简风格指南"></a>附录 - 精简风格指南</h2><p>这是可移植样式指南的简短摘要。有关解释示例和例外情况，请参阅正文。</p><h3 id="基本样式元素"><a href="#基本样式元素" class="headerlink" title="基本样式元素"></a>基本样式元素</h3><ul><li>使用 SystemVerilog-2012 约定，文件命名为 module.sv，每个模块一个文件</li><li>只有 ASCII，每行<strong>100 个字符，****没有</strong>制表符，所有配对关键字的每个缩进<strong>两个空格。</strong></li><li>C++ 风格注释<code>//</code></li><li>对于一行中的多个项目，<strong>一个</strong>空格必须分隔逗号和下一个字符</li><li>在关键字和二元运算符周围包含<strong>空格</strong></li><li>案例项目和冒号、函数/任务/宏调用和左括号之间<strong>没有空格</strong></li><li>换行应该缩进<strong>四个</strong>空格</li><li><code>begin</code>必须与前面的关键字在同一行并结束行</li><li><code>end</code>必须开始一个新行</li></ul><h3 id="构造命名"><a href="#构造命名" class="headerlink" title="构造命名"></a>构造命名</h3><ul><li>对实例名称、信号、声明、变量、类型使用<strong>lower_snake_case</strong></li><li>对可调参数、枚举值名称使用<strong>UpperCamelCase</strong></li><li>将<strong>ALL_CAPS</strong>用于常量并定义宏</li><li>主时钟信号命名为<code>clk</code>。所有时钟信号必须以<code>clk_</code></li><li>复位信号为<strong>低电平有效</strong>和<strong>异步</strong>，默认名称为 <code>rst_n</code></li><li>信号名称应具有描述性并在整个层次结构中保持一致</li></ul><h3 id="信号和类型的后缀"><a href="#信号和类型的后缀" class="headerlink" title="信号和类型的后缀"></a>信号和类型的后缀</h3><ul><li>添加<code>_i</code>到模块输入、<code>_o</code>模块输出或<code>_io</code>双向模块信号</li><li>注册信号的输入（下一个状态）应该有<code>_d</code>，输出<code>_q</code>作为后缀</li><li>信号的流水线版本应命名为<code>_q2</code>,<code>_q3</code>等以反映它们的延迟</li><li>低电平有效信号应使用<code>_n</code>。当使用差分信号 <code>_p</code>用于高电平有效</li><li>枚举类型应以<code>_e</code></li><li>多个后缀不会用 . 分隔<code>_</code>。<code>n</code>应该先出现 <code>i</code>，<code>o</code>或<code>io</code>最后出现</li></ul><h3 id="语言特点-1"><a href="#语言特点-1" class="headerlink" title="语言特点"></a>语言特点</h3><ul><li>对模块使用<strong>完整的端口声明样式</strong>，首先声明的任何时钟和复位</li><li>使用<strong>命名参数</strong>进行实例化，所有声明的端口必须存在，没有<code>.*</code></li><li>顶级参数优于<code> </code>define`全局参数</li><li>使用<strong>符号命名的常量</strong>而不是原始数字</li><li>应<code>localparam</code>在单独的 <strong>.svh</strong>文件中声明局部常量和全局常量。</li><li><code>logic</code>优于<code>reg</code>and <code>wire</code>，明确声明所有信号</li><li><code>always_comb</code>,<code>always_ff</code>并且<code>always_latch</code>优先于<code>always</code></li><li>不鼓励使用接口</li><li>顺序逻辑必须使用<strong>非阻塞</strong>赋值</li><li>组合块必须使用<strong>块</strong>分配</li><li>不鼓励使用锁存器，尽可能使用触发器</li><li><code>X</code>强烈建议不要在 RTL 中使用分配，而是使用 SVA 来检查无效行为。</li><li><code>assign</code>在可行的情况下首选语句。</li><li>使用<code>unique case</code>并始终定义一个<code>default</code>案例</li><li>在使用有符号算术的地方使用可用的有符号算术结构</li><li>打印时使用<code>0b</code>和<code>0x</code>作为二进制和十六进制的前缀。用于 <code>_</code>清晰</li><li>使用逻辑结构 (ie <code>||</code>) 进行逻辑比较，按位 (ie <code>|</code>) 进行数据比较</li><li>位向量和压缩数组必须是 little-endian，unpacked 数组必须是 big-endian</li><li>FSM：状态寄存器的过程中除了复位之外不应该执行<strong>任何逻辑</strong></li><li>一个组合流程应该首先定义流程中所有输出的<strong>默认值</strong></li><li>下一个状态变量的默认值应该是当前状态</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TestBench文件编写</title>
      <link href="/2022/10/27/ru-he-xie-testbench/"/>
      <url>/2022/10/27/ru-he-xie-testbench/</url>
      
        <content type="html"><![CDATA[<h1 id="TestBench文件编写"><a href="#TestBench文件编写" class="headerlink" title="TestBench文件编写"></a>TestBench文件编写</h1><pre class=" language-verilog"><code class="language-verilog"><span class="token constant">`timescale</span> <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ps      <span class="token comment" spellcheck="true">//时间精度</span><span class="token constant">`define</span> clk_perilod <span class="token number">20</span>    <span class="token comment" spellcheck="true">//时钟周期可变</span><span class="token keyword">module</span> test_file_tb<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//无端口列表模块名 也可以写成modeule test_file_tb();</span><span class="token comment" spellcheck="true">//==================&lt;端口>==================================================</span><span class="token keyword">reg</span>                         clk                 <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//时钟，50Mhz</span><span class="token keyword">reg</span>                         rst_n               <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//复位，低电平有效</span><span class="token keyword">reg</span>  <span class="token punctuation">[</span>XX<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>                 in                  <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span><span class="token keyword">wire</span> <span class="token punctuation">[</span>XX<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">]</span>                 out                 <span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//--------------------------------------------------------------------------</span><span class="token comment" spellcheck="true">//--    模块例化</span><span class="token comment" spellcheck="true">//--------------------------------------------------------------------------</span>my_design u_my_design<span class="token punctuation">(</span>    <span class="token punctuation">.</span>clk                    <span class="token punctuation">(</span>clk                <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>rst_n                  <span class="token punctuation">(</span>rst_n              <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>in                     <span class="token punctuation">(</span>in                 <span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">.</span>out                    <span class="token punctuation">(</span>out                <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------</span><span class="token comment" spellcheck="true">//--    时钟信号和复位信号</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------</span><span class="token keyword">initial</span> <span class="token keyword">begin</span>    clk <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">forever</span>        #<span class="token punctuation">(</span><span class="token constant">`Clock</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> clk <span class="token operator">=</span> <span class="token operator">~</span>clk<span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">initial</span> <span class="token keyword">begin</span>    rst_n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> #<span class="token punctuation">(</span><span class="token constant">`Clock</span><span class="token operator">*</span><span class="token number">20</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    rst_n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------</span><span class="token comment" spellcheck="true">//--    设计输入信号</span><span class="token comment" spellcheck="true">//----------------------------------------------------------------------</span><span class="token keyword">initial</span> <span class="token keyword">begin</span>    in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    #<span class="token punctuation">(</span><span class="token constant">`Clock</span><span class="token operator">*</span><span class="token number">20</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//初始化完成</span>    <span class="token property">$stop</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token keyword">endmodule</span>在这里插入代码片</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>哈希算法-SHA256</title>
      <link href="/2022/05/04/ha-xi-suan-fa-sha256/"/>
      <url>/2022/05/04/ha-xi-suan-fa-sha256/</url>
      
        <content type="html"><![CDATA[<h2 id="消息预处理-在计算消息的哈希摘要之前需要对消息进行预处理"><a href="#消息预处理-在计算消息的哈希摘要之前需要对消息进行预处理" class="headerlink" title="消息预处理(在计算消息的哈希摘要之前需要对消息进行预处理)"></a>消息预处理(在计算消息的哈希摘要之前需要对消息进行预处理)</h2><h3 id="对消息进行补码处理-假设消息的二进制编码长度为l位-首先在消息末尾补上一位”1”-然后再补上k个”0”-其中k为下列方程的最小非负整数"><a href="#对消息进行补码处理-假设消息的二进制编码长度为l位-首先在消息末尾补上一位”1”-然后再补上k个”0”-其中k为下列方程的最小非负整数" class="headerlink" title="对消息进行补码处理: 假设消息的二进制编码长度为l位. 首先在消息末尾补上一位”1”, 然后再补上k个”0”, 其中k为下列方程的最小非负整数"></a>对消息进行补码处理: 假设消息的二进制编码长度为l位. 首先在消息末尾补上一位”1”, 然后再补上k个”0”, 其中k为下列方程的最小非负整数</h3><p><img src="https://api2.mubu.com/v3/document_image/1f2cb0f9-a000-4048-bb4f-ccff1c252a5f-17161769.jpg" alt="img"></p><h3 id="举个例子具体说明如何进行补码，以消息“abc”为例："><a href="#举个例子具体说明如何进行补码，以消息“abc”为例：" class="headerlink" title="举个例子具体说明如何进行补码，以消息“abc”为例："></a>举个例子具体说明如何进行补码，以消息“abc”为例：</h3><p><img src="https://api2.mubu.com/v3/document_image/16cece93-667d-4ace-b40d-37af1322e2a6-17161769.jpg" alt="img"></p><p>上图中最后的64位为原来消息序列长度的64位二进制表示(原来长度为24)，这里就存在一个限制原来消息序列长度不可超过2^64(绝大多数情况下这个数已经够大了)</p><h3 id="对补码后的二进制序列进行切块："><a href="#对补码后的二进制序列进行切块：" class="headerlink" title="对补码后的二进制序列进行切块："></a>对补码后的二进制序列进行切块：</h3><p><img src="https://api2.mubu.com/v3/document_image/1076c8b5-7900-447c-a74f-f84d0e760ad0-17161769.jpg" alt="img"></p><p><img src="https://api2.mubu.com/v3/document_image/b662b0a0-ca61-4724-9e44-35fecb288edc-17161769.jpg" alt="img"></p><h2 id="摘要计算主循环"><a href="#摘要计算主循环" class="headerlink" title="摘要计算主循环"></a>摘要计算主循环</h2><h3 id="将上述得到1632bits拓展成6432bits-原先16个32记为w-0-w-1-…-w-15-，后面48个字w-16-w-63-由下面公式得到"><a href="#将上述得到1632bits拓展成6432bits-原先16个32记为w-0-w-1-…-w-15-，后面48个字w-16-w-63-由下面公式得到" class="headerlink" title="将上述得到1632bits拓展成6432bits(原先16个32记为w[0],w[1],…,w[15]，后面48个字w[16]~w[63]由下面公式得到)"></a>将上述得到16<em>32bits拓展成64</em>32bits(原先16个32记为w[0],w[1],…,w[15]，后面48个字w[16]~w[63]由下面公式得到)</h3><p><img src="https://api2.mubu.com/v3/document_image/1d5b6f6c-1bc5-4b70-9bc1-1df934504595-17161769.jpg" alt="img"></p><p><img src="https://api2.mubu.com/v3/document_image/ae69548a-fffe-434b-8921-62573389f878-17161769.jpg" alt="img"></p><h3 id="哈希计算主循环"><a href="#哈希计算主循环" class="headerlink" title="哈希计算主循环"></a>哈希计算主循环</h3><p><img src="https://api2.mubu.com/v3/document_image/2f649fde-56a1-4fbb-a02a-e4f60e939940-17161769.jpg" alt="img"></p><h2 id="Python代码实现-https-gitee-com-wutaoizp-hash-algorithm-sha256-tree-master-SHA256"><a href="#Python代码实现-https-gitee-com-wutaoizp-hash-algorithm-sha256-tree-master-SHA256" class="headerlink" title="Python代码实现:https://gitee.com/wutaoizp/hash-algorithm---sha256/tree/master/SHA256"></a>Python代码实现:<a href="https://gitee.com/wutaoizp/hash-algorithm---sha256/tree/master/SHA256">https://gitee.com/wutaoizp/hash-algorithm---sha256/tree/master/SHA256</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客推送相关</title>
      <link href="/2022/05/04/bo-ke-tui-song-xiang-guan/"/>
      <url>/2022/05/04/bo-ke-tui-song-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h2 id="如何快速将本地文档推送至站点"><a href="#如何快速将本地文档推送至站点" class="headerlink" title="如何快速将本地文档推送至站点"></a>如何快速将本地文档推送至站点</h2><h3 id="删除博客目录下的-deploy-git-和-public-文件夹"><a href="#删除博客目录下的-deploy-git-和-public-文件夹" class="headerlink" title="删除博客目录下的 .deploy_git 和 public 文件夹"></a>删除博客目录下的 .deploy_git 和 public 文件夹</h3><p>清除缓存</p><pre class=" language-bash"><code class="language-bash">$ hexo clean</code></pre><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: [Deployment](</p><p>或者直接：</p><pre class=" language-bash"><code class="language-bash">$ hexo clean <span class="token operator">&amp;&amp;</span> hexo g</code></pre><p>再进行</p><pre class=" language-bash"><code class="language-bash">$ hexo s</code></pre><p>进行本地验证</p><p>最后</p><pre class=" language-bash"><code class="language-bash">$ hexo d</code></pre><p>推送至网页</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/01/hello-world/"/>
      <url>/2022/05/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
